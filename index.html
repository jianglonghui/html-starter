<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>ç¡¬æ ¸å±±è·¯é©¾é©¶ - æ— é™ç”Ÿæˆç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; }
        
        #cockpit-overlay {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            background-image: url('image22.png'); 
            background-size: cover; background-position: center bottom;
            filter: 
                brightness(0.7)    /* å‹ä½äº®åº¦ï¼Œæ¨¡æ‹Ÿè½¦å†…æš—å…‰ç¯å¢ƒ */
                contrast(1.1)      /* ç¨å¾®å¢å¼ºå¯¹æ¯”åº¦ */
                saturate(0.8)      /* é™ä½é¥±å’Œåº¦ï¼Œå»æ‰é‚£ç§å»‰ä»·çš„å½©è‰²æ„Ÿ */
                drop-shadow(0px 0px 20px rgba(0,0,0,0.5)); /* å¢åŠ è¾¹ç¼˜æš—éƒ¨ */
            
            /* --- æ–°å¢ï¼šæš—è§’æ•ˆæœ (Vignette) --- */
            mask-image: radial-gradient(circle, white 60%, black 120%);
        }

        #mirror-left {
            position: absolute; left: 2%; bottom: 51%; width: 14vw; height: 7vw;
            z-index: 5; border-radius: 50% 50% 40% 40%; border: 3px solid #333;
            background: #000; overflow: hidden; transform: rotate(2deg) scale(-1, 1);
        }

        #info {
            position: absolute; top: 10px; left: 10px; color: #fff;
            font-family: monospace; font-size: 16px; z-index: 20;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 4px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>



<div id="info">
    â›°ï¸ ç§‹åå±±ç‰¹è®­ (æ— é™ç”Ÿæˆç‰ˆ)<br>
    W åŠ é€Ÿ | S åˆ¹è½¦/å€’è½¦ | A/D è½¬å‘ | Space æ‰‹åˆ¹<br>
    M å¼€å…³éŸ³ä¹ | V åˆ‡æ¢è§†è§’ | R é‡ç½®<br>
    C é‡‡é›†æ¨¡å¼ | L å­¦ä¹  | T è®­ç»ƒ
</div>
<div id="cockpit-overlay"></div>
<div id="mirror-left"></div>

<script type="module">
    import * as THREE from 'three';
    import * as CANNON from 'cannon-es';
    import { Sky } from 'https://unpkg.com/three@0.160.0/examples/jsm/objects/Sky.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { TrafficManager, NPCVehicle, calculateRoadPoint} from './traffic.js';
    import {AutoTuner} from './AutoTuner.js';
    import { trainedData } from './trained_data.js';

    let orbitControls;

    let world, scene, camera, renderer;
    let mirrorCamera, mirrorRenderer;
    let vehicle, chassisBody;
    let sun;
    let visualChassis, visualWheels = [];
    let isFirstPerson = true; // é»˜è®¤å¼€å¯ç¬¬ä¸€äººç§°
    let bgMusic;
    let isMusicPlaying = false;
    let traffic;

    let audioCtx;
    let windNoise;
    let windGain;
    let windFilter;
    let masterGain; // æ–°å¢ä¸»å¼€å…³

    let currentTrackIndex = 0;
    const playlist = [
        'traffic-264578.mp3', // ä½ çš„ç¬¬ä¸€é¦–æ­Œ
        'song2.mp3',          // ä½ çš„ç¬¬äºŒé¦–æ­Œï¼ˆç¡®ä¿æœ¬åœ°æœ‰è¿™ä¸ªæ–‡ä»¶ï¼‰
        'song3.mp3'           // ä½ çš„ç¬¬ä¸‰é¦–æ­Œ
    ];
    let lastSafePosition = new CANNON.Vec3(0, 2, 0);
    let lastSafeQuaternion = new CANNON.Quaternion();
    
    // --- æ— é™è·¯æ®µç®¡ç†å˜é‡ ---
    const roadSegments = []; // å­˜å‚¨è·¯æ®µå¯¹è±¡ï¼Œç”¨äºåç»­åˆ é™¤
    let segmentCounter = 0;  // å½“å‰ç”Ÿæˆçš„æ®µæ•°
    let prevX = 0, prevY = 0, prevZ = 0; // ä¸Šä¸€æ®µè·¯æœ«ç«¯åæ ‡
    const segLen = 15;        // æ¯æ®µé•¿åº¦
    const roadWidth = 14;     // è·¯å®½
    let roadMat, wallMat, roadTex; 
    // -----------------------

    

    let isTuningMode = false; // è®¾ä¸º false å…ˆè®°å½•äººç±»é©¾é©¶æ•°æ®
    let tuner = null;
    let tuningTimer = 0;
    const TEST_DURATION = 60 * 20; // æ¯ä»£æµ‹è¯• 20 ç§’ (60å¸§/ç§’ * 20)
    let globalCarId = 0; // å…¨å±€å”¯ä¸€è½¦è¾†ID

    // äººç±»é©¾é©¶æ•°æ®è®°å½•ï¼ˆè¡Œä¸ºå…‹éš†ï¼‰
    let humanDrivingData = {
        samples: [],           // çŠ¶æ€-åŠ¨ä½œå¯¹
        totalCTE: 0,
        sampleCount: 0,
        totalDistance: 0,
        lastZ: 0,
        lastSpeed: 0           // ç”¨äºè®¡ç®—åŠ é€Ÿåº¦
    };

    // é‡‡æ ·ç›®æ ‡ç‚¹å¯è§†åŒ–ï¼ˆè®©äººç±»çœ‹åˆ°AIçœ‹åˆ°çš„ç›®æ ‡ï¼‰
    let targetMarker = null;
    const SAMPLE_LOOK_AHEAD = 18; // é‡‡æ ·ç”¨çš„é¢„ç„è·ç¦»ï¼Œå’ŒAIè®­ç»ƒæ—¶ä¸€è‡´
    let isCollectingMode = false; // é‡‡é›†æ¨¡å¼å¼€å…³

    // å­¦ä¹ åˆ°çš„æ§åˆ¶ç­–ç•¥
    let learnedPolicy = null;

    // ä»æ–‡ä»¶åŠ è½½é¢„è®­ç»ƒæ•°æ®
    if (trainedData.samples && trainedData.samples.length > 0) {
        humanDrivingData.samples = trainedData.samples;
        window.humanDrivingSamples = trainedData.samples;
        console.log(`%c ğŸ“‚ ä»æ–‡ä»¶åŠ è½½äº† ${trainedData.samples.length} ä¸ªæ ·æœ¬`, 'color: #0f0;');
    }
    if (trainedData.learnedPolicy) {
        learnedPolicy = trainedData.learnedPolicy;
        window.learnedPolicy = trainedData.learnedPolicy;
        console.log('%c ğŸ“‚ ä»æ–‡ä»¶åŠ è½½äº†å­¦ä¹ ç­–ç•¥', 'color: #0f0;');
    }
    if (trainedData.bestDNA) {
        window.bestTrainedDNA = trainedData.bestDNA;
        console.log('%c ğŸ“‚ ä»æ–‡ä»¶åŠ è½½äº†æœ€ä½³å‚æ•°', 'color: #0f0;', trainedData.bestDNA);
    }

    // å¯¼å‡ºå½“å‰æ•°æ®ï¼ˆå¤åˆ¶è¾“å‡ºåˆ° trained_data.jsï¼‰
    window.exportTrainingData = function() {
        const data = {
            samples: humanDrivingData.samples,
            learnedPolicy: learnedPolicy,
            bestDNA: window.bestTrainedDNA
        };
        const jsonStr = JSON.stringify(data, null, 2);
        console.log('%c ğŸ“‹ å¤åˆ¶ä»¥ä¸‹å†…å®¹åˆ° trained_data.js:', 'background: #f0a; color: #fff; font-size: 14px;');
        console.log(`export const trainedData = ${jsonStr};`);

        // ä¹Ÿæä¾›ä¸‹è½½
        const blob = new Blob([`export const trainedData = ${jsonStr};`], {type: 'text/javascript'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'trained_data.js';
        a.click();
        URL.revokeObjectURL(url);
        console.log('%c â¬‡ï¸ æ–‡ä»¶å·²ä¸‹è½½ï¼Œæ›¿æ¢é¡¹ç›®ä¸­çš„ trained_data.js å³å¯', 'color: #0ff;');
    };

    // æŸ¥çœ‹äººç±»é©¾é©¶æ•°æ®
    window.getHumanBaseline = function() {
        if (humanDrivingData.samples.length === 0) {
            console.warn('æ²¡æœ‰è®°å½•åˆ°æ•°æ®ï¼Œè¯·å…ˆé©¾é©¶ä¸€æ®µæ—¶é—´ï¼');
            return null;
        }
        const avgCTE = humanDrivingData.totalCTE / humanDrivingData.sampleCount;
        const avgSpeed = humanDrivingData.samples.reduce((a, b) => a + b.speed, 0) / humanDrivingData.samples.length;
        console.log('%c äººç±»é©¾é©¶æ•°æ® ', 'background: #0a0; color: #fff; font-size: 14px;');
        console.table({
            'æ ·æœ¬æ•°': humanDrivingData.samples.length,
            'å¹³å‡CTE': avgCTE.toFixed(3) + 'm',
            'å¹³å‡é€Ÿåº¦': avgSpeed.toFixed(1) + 'm/s',
            'æ€»è¡Œé©¶è·ç¦»': humanDrivingData.totalDistance.toFixed(1) + 'm'
        });
        return { avgCTE, avgSpeed, samples: humanDrivingData.samples };
    };

    // ä»äººç±»æ•°æ®å­¦ä¹ æ§åˆ¶ç­–ç•¥ï¼ˆçº¿æ€§å›å½’æ‹Ÿåˆï¼‰
    window.learnFromHuman = function() {
        const samples = humanDrivingData.samples;
        if (samples.length < 100) {
            console.warn('æ•°æ®å¤ªå°‘ï¼Œè¯·è‡³å°‘é©¾é©¶30ç§’ä»¥ä¸Šï¼å½“å‰æ ·æœ¬æ•°ï¼š' + samples.length);
            return;
        }

        const n = samples.length;

        // 1. è®¡ç®—è½¬å‘å¢ç›Šï¼šsteer = steerGain * angleToTarget
        // ä½¿ç”¨æœ€å°äºŒä¹˜æ³•ï¼šsteerGain = Î£(angle * steer) / Î£(angleÂ²)
        let sumAngle2 = 0, sumAngleSteer = 0;
        samples.forEach(s => {
            sumAngle2 += s.angleToTarget * s.angleToTarget;
            sumAngleSteer += s.angleToTarget * s.steer;
        });
        const steerGain = Math.abs(sumAngleSteer / (sumAngle2 + 0.001));

        // 2. è®¡ç®—å¹³å‡é€Ÿåº¦
        const avgSpeed = samples.reduce((a, b) => a + b.speed, 0) / n;

        // 3. ä¼°ç®—å¼•æ“åŠ›ï¼šåŸºäºå¹³å‡é€Ÿåº¦åæ¨
        // AIå…¬å¼: force = (targetSpeed - currentSpeed) * engineForce
        // å‡è®¾ç¨³æ€æ—¶ force â‰ˆ é˜»åŠ›ï¼Œé€Ÿåº¦ä¸engineForceæˆæ­£æ¯”
        // ç»éªŒå…¬å¼ï¼šavgSpeed â‰ˆ 15m/s å¯¹åº” engineForce â‰ˆ 3500
        const engineForce = (avgSpeed / 15) * 3500;

        // 4. å¹³å‡CTEä½œä¸ºåŸºå‡†
        const avgCTE = humanDrivingData.totalCTE / humanDrivingData.sampleCount;

        learnedPolicy = {
            steerGain: steerGain,
            engineForce: engineForce,
            avgSpeed: avgSpeed,
            avgCTE: avgCTE,
            sampleCount: n
        };

        // åŒæ­¥åˆ°å…¨å±€ï¼Œä¾›AutoTunerå’ŒAIä½¿ç”¨
        window.learnedPolicy = learnedPolicy;
        window.humanDrivingSamples = samples;  // è¡Œä¸ºå…‹éš†ç”¨

        console.log('%c ğŸ“ å­¦ä¹ å®Œæˆï¼', 'background: #f0a; color: #fff; font-size: 16px;');
        console.log('%c è®¡ç®—å‡ºçš„AIå‚æ•°ï¼š', 'color: #0ff; font-weight: bold;');
        console.table({
            'steerGain (è½¬å‘å¢ç›Š)': learnedPolicy.steerGain.toFixed(3),
            'engineForce (å¼•æ“åŠ›)': learnedPolicy.engineForce.toFixed(0),
            'äººç±»å¹³å‡é€Ÿåº¦': learnedPolicy.avgSpeed.toFixed(1) + ' m/s',
            'äººç±»å¹³å‡CTE': learnedPolicy.avgCTE.toFixed(3) + ' m',
            'æ ·æœ¬æ•°é‡': learnedPolicy.sampleCount
        });
        console.log('%c è¡Œä¸ºå…‹éš†å·²å¯ç”¨ï¼AIå°†ç›´æ¥æ¨¡ä»¿ä½ çš„é©¾é©¶é£æ ¼', 'color: #0f0;');

        window.humanBaseline = {
            avgCTE: avgCTE,
            avgSpeed: avgSpeed
        };

        return learnedPolicy;
    };

    // å¼€å§‹è®­ç»ƒæ¨¡å¼
    window.startTraining = function() {
        if (!learnedPolicy) {
            console.warn('è¯·å…ˆè°ƒç”¨ learnFromHuman() å­¦ä¹ äººç±»é©¾é©¶ç­–ç•¥ï¼');
            return;
        }
        isTuningMode = true;
        console.log('%c ğŸš— å¼€å§‹AIè®­ç»ƒï¼Œä½¿ç”¨å­¦ä¹ åˆ°çš„ç­–ç•¥ ', 'background: #00f; color: #fff;');
    };

    // åœæ­¢è®­ç»ƒï¼Œåº”ç”¨ç»“æœåˆ°æ™®é€šæ¨¡å¼
    window.stopTraining = function() {
        if (!isTuningMode) {
            console.warn('å½“å‰ä¸åœ¨è®­ç»ƒæ¨¡å¼');
            return;
        }

        // æ¸…ç†è®­ç»ƒè½¦è¾†
        if (tuner && tuner.population) {
            tuner.population.forEach(ind => {
                if (ind.car) {
                    ind.car.destroy();
                    ind.car = null;
                }
            });
        }

        isTuningMode = false;
        tuner = null;

        console.log('%c ğŸ è®­ç»ƒç»“æŸï¼', 'background: #0a0; color: #fff; font-size: 16px;');
        if (window.bestTrainedDNA) {
            console.log('%c æœ€ä½³å‚æ•°å·²åº”ç”¨åˆ°æ™®é€šæ¨¡å¼ï¼š', 'color: #0ff;');
            console.table(window.bestTrainedDNA);
        }
        if (window.humanDrivingSamples) {
            console.log(`è¡Œä¸ºå…‹éš†æ ·æœ¬ï¼š${window.humanDrivingSamples.length} ä¸ª`);
        }
    };

    init();
    animate();

    function initWind() {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const bufferSize = 4 * audioCtx.sampleRate;
        const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            output[i] *= 0.11;
            b6 = white * 0.115926;
        }

        windNoise = audioCtx.createBufferSource();
        windNoise.buffer = noiseBuffer;
        windNoise.loop = true;

        // --- æ ¸å¿ƒï¼šä½é€šæ»¤æ³¢å™¨ (äº§ç”Ÿéš†éš†å£°) ---
        windFilter = audioCtx.createBiquadFilter();
        windFilter.type = 'lowpass'; // æ”¹ä¸ºä½é€šï¼Œæ»¤æ‰æ²™æ²™å£°
        windFilter.frequency.value = 100; // åªè¦æä½é¢‘
        windFilter.Q.value = 2.0; // å¢åŠ ä¸€ç‚¹å…±é¸£æ„Ÿ

        // è°ƒåˆ¶å±‚ï¼šè´Ÿè´£â€œéš†â€”â€”éš†â€”â€”â€çš„èŠ‚å¥æ„Ÿ
        windGain = audioCtx.createGain();
        windGain.gain.value = 0.5;

        // ä½¿ç”¨æ›´æ…¢ã€ä¸è§„åˆ™çš„æŒ¯è¡
        const lfo = audioCtx.createOscillator();
        lfo.type = 'triangle'; // ä¸‰è§’æ³¢æ¯”æ­£å¼¦æ³¢æ›´æœ‰æ’å‡»æ„Ÿ
        lfo.frequency.value = 1.5; 
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 0.3; // æ³¢åŠ¨å¾ˆå¤§ï¼Œäº§ç”Ÿèµ·ä¼æ„Ÿ
        lfo.connect(lfoGain);
        lfoGain.connect(windGain.gain);
        lfo.start();

        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0;

        // è¿è·¯
        windNoise.connect(windFilter);
        windFilter.connect(windGain);
        windGain.connect(masterGain);
        masterGain.connect(audioCtx.destination);

        windNoise.start();
    }

    function initMusic() {
        // ä½¿ç”¨ä¸€ä¸ªèˆ’ç¼“çš„ Lo-fi é£æ ¼å…ç‰ˆæƒéŸ³ä¹é“¾æ¥ (ç¤ºä¾‹)
        const musicUrl = 'traffic-264578.mp3'; 
        
        bgMusic = new Audio(musicUrl);
        bgMusic.loop = true;      // å¾ªç¯æ’­æ”¾
        bgMusic.volume = 0.4;    // éŸ³é‡ 40%ï¼Œä¸å¹²æ‰°é©¾é©¶åˆ¤æ–­
    }

    function init() {

        world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
        roadMat = new CANNON.Material();
        wallMat = new CANNON.Material();
        const wheelMat = new CANNON.Material();

        const roadContact = new CANNON.ContactMaterial(roadMat, wheelMat, { friction: 1.5, restitution: 0.0 });
        const wallContact = new CANNON.ContactMaterial(wallMat, wheelMat, { friction: 3, restitution: 0.0 });
        
        world.addContactMaterial(roadContact);
        world.addContactMaterial(wallContact);

        scene = new THREE.Scene();

        // --- 1. å…ˆåˆ›å»ºå¤ªé˜³ç¯å…‰ (DirectionalLight) ---
        sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.castShadow = true;
        // é…ç½®é˜´å½±èŒƒå›´
        sun.shadow.camera.left = -150; sun.shadow.camera.right = 150;
        sun.shadow.camera.top = 150; sun.shadow.camera.bottom = -150;
        sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
        scene.add(sun);

        // 1. åˆ›å»ºå¤©ç©ºå¯¹è±¡
        const sky = new Sky();
        sky.scale.setScalar(450000); // æå…¶å·¨å¤§çš„çƒä½“
        scene.add(sky);

        // 2. é…ç½®å¤§æ°”å‚æ•°
        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 0.5;      // æµ‘æµŠåº¦ (1-20): è¶Šé«˜è¶Šåƒå¤§é›¾å¤©æˆ–é»„æ˜
        skyUniforms['rayleigh'].value = 4;       // ç‘åˆ©æ•£å°„ (0-4): è¶Šé«˜å¤©ç©ºè¶Šè“
        skyUniforms['mieCoefficient'].value = 0.001; // æ•£å°„ç³»æ•°: æ¨¡æ‹Ÿç©ºæ°”ä¸­çš„é¢—ç²’
        skyUniforms['mieDirectionalG'].value = 0.95;  // å¤ªé˜³å…‰æ™•çš„æ‰©æ•£åº¦

        // 3. è®¾ç½®å¤ªé˜³ä½ç½®
        const sunPosition = new THREE.Vector3();
        const elevation = 2;   // å¤ªé˜³é«˜åº¦è§’ (0=åœ°å¹³çº¿, 90=å¤´é¡¶)
        const azimuth = 180;   // å¤ªé˜³æ–¹ä½è§’
        const phi = THREE.MathUtils.degToRad(90 - elevation);
        const theta = THREE.MathUtils.degToRad(azimuth);
        sunPosition.setFromSphericalCoords(1, phi, theta);

        // å°†ä½ç½®ä¼ é€’ç»™å¤©ç©ºç€è‰²å™¨
        skyUniforms['sunPosition'].value.copy(sunPosition);

        // 4. åŒæ­¥åœºæ™¯å…‰ç…§
        // æ‰¾åˆ°ä½ åŸæœ‰çš„ DirectionalLight (sun)ï¼Œè®©å®ƒçš„ä½ç½®ä¸å¤©ç©ºçš„å¤ªé˜³ä½ç½®å¯¹é½
        sun.position.copy(sunPosition.multiplyScalar(100)); 

        // 5. ä¼˜åŒ–é›¾æ°”é¢œè‰² (è®©è¿œå¤„çš„é›¾ä¸å¤©ç©ºåœ°å¹³çº¿é¢œè‰²èåˆ)
        // è¿™é‡Œå»ºè®®ç”¨ FogExp2ï¼Œé¢œè‰²è®¾ä¸ºç•¥å¾®å‘ç™½/æµ…è“
        scene.fog = new THREE.FogExp2(0xaaccff, 0.0008);

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x443322, 1.5);
        scene.add(hemiLight);


        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        mirrorCamera = new THREE.PerspectiveCamera(60, 1.8, 0.1, 500);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        renderer.toneMapping = THREE.ACESFilmicToneMapping; // ç”µå½±çº§è‰²è°ƒæ˜ å°„
        renderer.toneMappingExposure = 1.0;                // æ›å…‰åº¦
        renderer.outputColorSpace = THREE.SRGBColorSpace;   // å¼€å¯ sRGB è‰²å½©ç©ºé—´
        document.body.appendChild(renderer.domElement);

        // è‡ªç”±ç›¸æœºæ§åˆ¶ (AutoTuneræ¨¡å¼)
        orbitControls = new OrbitControls(camera, renderer.domElement);
        orbitControls.enableDamping = true;
        orbitControls.dampingFactor = 0.05;
        orbitControls.target.set(0, 0, -100); // çœ‹å‘è·¯çš„æ–¹å‘
        camera.position.set(0, 50, 50);       // ä¿¯è§†åˆå§‹ä½ç½®
        orbitControls.update();

        const mDiv = document.getElementById('mirror-left');
        mirrorRenderer = new THREE.WebGLRenderer({ alpha: false });
        mirrorRenderer.setSize(mDiv.clientWidth, mDiv.clientHeight);
        mDiv.appendChild(mirrorRenderer.domElement);

        // å‡†å¤‡è·¯é¢çº¹ç†
        const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle='#666'; ctx.fillRect(0,0,128,128);
        ctx.fillStyle='#fff'; ctx.fillRect(60,0,8,40); ctx.fillRect(60,64,8,40);
        roadTex = new THREE.CanvasTexture(canvas);
        roadTex.wrapS = THREE.RepeatWrapping; roadTex.wrapT = THREE.RepeatWrapping;

        // åˆå§‹åŒ–ç”Ÿæˆå‰30æ®µè·¯
        for(let i=0; i<30; i++) {
            generateNextSegment();
        }

        // è½¦è¾†é…ç½®
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.2, 2.2));
        chassisBody = new CANNON.Body({ mass: 1500 });
        chassisBody.addShape(chassisShape);
        chassisBody.position.set(0, 2, -5);
        chassisBody.angularDamping = 0.5;

        // è§†è§‰è½¦èº«ç»„
        visualChassis = new THREE.Group();
        
        // 1. åº•ç›˜/ä¸»ä½“ (çº¢è‰²)
        const bodyMesh = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.6, 4.4),
            new THREE.MeshStandardMaterial({ color: 0xcc0000, metalness: 0.8, roughness: 0.2 })
        );
        bodyMesh.position.y = 0.3;
        bodyMesh.castShadow = true;
        visualChassis.add(bodyMesh);

        // 2. é©¾é©¶èˆ± (é»‘è‰²ç»ç’ƒæ„Ÿ)
        const cabin = new THREE.Mesh(
            new THREE.BoxGeometry(1.5, 0.6, 1.8),
            new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 1, roughness: 0.1 })
        );
        cabin.position.set(0, 0.8, 0.4); // ä½äºè½¦èº«ååŠéƒ¨åˆ†
        visualChassis.add(cabin);

        // 3. è½¦å¤´å¤§ç¯
        const lightGeo = new THREE.BoxGeometry(0.4, 0.2, 0.1);
        const lightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff });
        const leftLight = new THREE.Mesh(lightGeo, lightMat);
        leftLight.position.set(-0.7, 0.3, -2.2);
        const rightLight = leftLight.clone();
        rightLight.position.set(0.7, 0.3, -2.2);
        visualChassis.add(leftLight, rightLight);

        // 4. è½¦å°¾ç¯ (çº¢è‰²)
        const tailLightMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x880000 });
        const leftTail = new THREE.Mesh(lightGeo, tailLightMat);
        leftTail.position.set(-0.7, 0.4, 2.2);
        const rightTail = leftTail.clone();
        rightTail.position.set(0.7, 0.4, 2.2);
        visualChassis.add(leftTail, rightTail);

        scene.add(visualChassis);

        vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
            indexRightAxis: 0, indexUpAxis: 1, indexForwardAxis: 2,
        });

        const wheelOptions = {
            radius: 0.45,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: 40,
            suspensionRestLength: 0.4,
            frictionSlip: 2.5,
            dampingRelaxation: 2.3, dampingCompression: 4.4,
            maxSuspensionForce: 100000,
            rollInfluence: 0.1,
            axleLocal: new CANNON.Vec3(1, 0, 0),
            chassisConnectionPointLocal: new CANNON.Vec3(0, 0, 0),
            maxSuspensionTravel: 0.2,
            customSlidingRotationalSpeed: -30,
            useCustomSlidingRotationalSpeed: true,
        };

        wheelOptions.chassisConnectionPointLocal.set(-1.1, 0, -1.4); vehicle.addWheel(wheelOptions);
        wheelOptions.chassisConnectionPointLocal.set(1.1, 0, -1.4); vehicle.addWheel(wheelOptions);
        wheelOptions.chassisConnectionPointLocal.set(-1.1, 0, 1.4); vehicle.addWheel(wheelOptions);
        wheelOptions.chassisConnectionPointLocal.set(1.1, 0, 1.4); vehicle.addWheel(wheelOptions);

        vehicle.addToWorld(world);

        const wheelGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.4, 24);
        wheelGeo.rotateZ(Math.PI/2);
        // è§†è§‰è½®å­é€ å‹ï¼šå¤–èƒ + è½®æ¯‚
        vehicle.wheelInfos.forEach(() => {
            const wheelGroup = new THREE.Group();
            
            // å¤–èƒ (é»‘è‰²åœ†æŸ±)
            const tire = new THREE.Mesh(
                new THREE.CylinderGeometry(0.45, 0.45, 0.4, 24),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            tire.rotateZ(Math.PI/2);
            
            // è½®æ¯‚ (é“¶è‰²è–„ç‰‡)
            const rim = new THREE.Mesh(
                new THREE.SphereGeometry(0.3, 16, 16, 0, Math.PI*2, 0, Math.PI/2),
                new THREE.MeshStandardMaterial({ color: 0xbbbbbb, metalness: 0.9 })
            );
            rim.rotateZ(Math.PI/2);
            rim.position.x = 0.21; // è´´åœ¨è½®èƒå¤–ä¾§

            wheelGroup.add(tire, rim);
            scene.add(wheelGroup);
            visualWheels.push(wheelGroup);
        });

        // åœ¨ init å‡½æ•°æœ«å°¾
        traffic = new TrafficManager(world, scene, chassisBody);
        traffic.generateWaypoints(chassisBody.position.z);

        // åˆ›å»ºé‡‡æ ·ç›®æ ‡ç‚¹æ ‡è®°ï¼ˆé†’ç›®çš„ç»¿è‰²å…‰çƒï¼‰
        const markerGeo = new THREE.SphereGeometry(1.5, 16, 16);
        const markerMat = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.8
        });
        targetMarker = new THREE.Mesh(markerGeo, markerMat);
        // æ·»åŠ å‘å…‰æ•ˆæœ
        const glowGeo = new THREE.SphereGeometry(2.5, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            transparent: true,
            opacity: 0.3
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        targetMarker.add(glow);
        targetMarker.visible = false; // é»˜è®¤éšè—ï¼ŒæŒ‰Cå¼€å¯
        scene.add(targetMarker);

        document.addEventListener('keydown', handler);
        document.addEventListener('keyup', handler);

        document.getElementById('cockpit-overlay').style.display = isFirstPerson ? 'block' : 'none';
    }

    // ================== æ ¸å¿ƒä¿®æ”¹ï¼šå•æ®µç”Ÿæˆé€»è¾‘ ==================
    function generateNextSegment() {
        const i = segmentCounter;
        
        // --- 1. è·¯å¾„ç®—æ³• (Så¼¯ + ä¸Šä¸‹å¡) ---
        let x = 0;
        let y = 0;
        if (i >= 5) { // å‰5æ®µä¿æŒç›´çº¿ï¼Œç»™ç©å®¶ååº”æ—¶é—´
            const t = i - 5;
            // Så¼¯ç»„åˆï¼š0.2å†³å®šé¢‘ç‡(è¶Šå¿«å¼¯è¶Šæ€¥)ï¼Œ35å†³å®šå¹…åº¦
            x = Math.sin(t * 0.2) * 35 + Math.sin(t * 0.05) * 60;
            // å¡åº¦ç»„åˆï¼š0.08å†³å®šèµ·ä¼é¢‘ç‡ï¼Œ25å†³å®šå±±ä¸˜é«˜åº¦
            y = Math.sin(t * 0.08) * 25; 
        }
        const z = -i * segLen;

        const segmentData = { bodies: [], meshes: [] };

        if (i > 0) {
            // è®¡ç®—å½“å‰æ®µç›¸å¯¹äºä¸Šä¸€æ®µçš„ä½ç§»
            const dx = x - prevX;
            const dy = y - prevY;
            const dz = z - prevZ;
            const horizontalLen = Math.sqrt(dx * dx + dz * dz);
            const totalLen = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            // è®¡ç®—è½¬å‘è§’(Yaw)å’Œä¿¯ä»°è§’(Pitch)
            const yaw = Math.atan2(dx, dz); 
            const pitch = -Math.atan2(dy, horizontalLen); 

            // åˆ›å»ºä¸´æ—¶ç‰©ç†å‘é‡ç”¨äºè®¡ç®—ï¼Œé¿å… TypeError: vadd is not a function
            const calcVec = new CANNON.Vec3();

            // --- 2. ç‰©ç†è·¯é¢ç”Ÿæˆ ---
            const roadBody = new CANNON.Body({ mass: 0, material: roadMat });
            // ç‰©ç†ç›’å­ç¨å¾®åŠ é•¿ä¸€ç‚¹(0.5)é˜²æ­¢è·¯æ®µç¼éš™é¢ ç°¸
            roadBody.addShape(new CANNON.Box(new CANNON.Vec3(roadWidth / 2, 1, totalLen / 2 + 0.5)));
            roadBody.position.set((x + prevX) / 2, (y + prevY) / 2 - 1, (z + prevZ) / 2);

            // è®¾ç½®æ—‹è½¬ï¼šå…ˆåèˆªå†ä¿¯ä»°
            const qYaw = new CANNON.Quaternion();
            qYaw.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), yaw);
            const qPitch = new CANNON.Quaternion();
            qPitch.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), pitch);
            roadBody.quaternion = qYaw.mult(qPitch);

            world.addBody(roadBody);
            segmentData.bodies.push(roadBody);

            // --- 3. è§†è§‰è·¯é¢ç”Ÿæˆ ---
            const roadMesh = new THREE.Mesh(
                new THREE.BoxGeometry(roadWidth, 0.2, totalLen + 1),
                new THREE.MeshLambertMaterial({ map: roadTex })
            );
            // å°†è§†è§‰æ¨¡å‹å¯¹é½åˆ°ç‰©ç†èº«ä½“çš„é¡¶é¢ (y=1çš„åœ°æ–¹)
            roadBody.pointToWorldFrame(new CANNON.Vec3(0, 1, 0), calcVec);
            roadMesh.position.set(calcVec.x, calcVec.y, calcVec.z);
            roadMesh.quaternion.copy(roadBody.quaternion);
            roadMesh.receiveShadow = true;
            scene.add(roadMesh);
            segmentData.meshes.push(roadMesh);

            // --- 4. å·¦ä¾§å±±å£ç”Ÿæˆ (è·Ÿéšå¡åº¦) ---
            const wallBody = new CANNON.Body({ mass: 0, material: wallMat });
            wallBody.addShape(new CANNON.Box(new CANNON.Vec3(1, 8, totalLen / 2)));
            roadBody.pointToWorldFrame(new CANNON.Vec3(-roadWidth / 2 - 1, 5, 0), wallBody.position);
            wallBody.quaternion.copy(roadBody.quaternion);
            world.addBody(wallBody);
            segmentData.bodies.push(wallBody);

            const wallMesh = new THREE.Mesh(
                new THREE.BoxGeometry(2, 16, totalLen + 2),
                new THREE.MeshLambertMaterial({ color: 0x4d3c2e })
            );
            wallMesh.position.set(wallBody.position.x, wallBody.position.y, wallBody.position.z);
            wallMesh.quaternion.copy(wallBody.quaternion);
            scene.add(wallMesh);
            segmentData.meshes.push(wallMesh);

            // --- 5. å³ä¾§æŠ¤æ ç”Ÿæˆ (è·Ÿéšå¡åº¦) ---
            const rail = new THREE.Mesh(
                new THREE.BoxGeometry(0.3, 1, totalLen),
                new THREE.MeshStandardMaterial({ color: 0xeeeeee })
            );
            roadBody.pointToWorldFrame(new CANNON.Vec3(roadWidth / 2 - 0.5, 0.6, 0), calcVec);
            rail.position.set(calcVec.x, calcVec.y, calcVec.z);
            rail.quaternion.copy(roadBody.quaternion);
            scene.add(rail);
            segmentData.meshes.push(rail);

            // --- 6. è£…é¥°ï¼šéšæœºä¹±çŸ³ ---
            if (Math.random() > 0.8) {
                const rock = new THREE.Mesh(
                    new THREE.DodecahedronGeometry(1 + Math.random() * 2, 0),
                    new THREE.MeshLambertMaterial({ color: 0x777777 })
                );
                roadBody.pointToWorldFrame(new CANNON.Vec3(-roadWidth / 2 - 3, 1, (Math.random()-0.5)*10), calcVec);
                rock.position.set(calcVec.x, calcVec.y, calcVec.z);
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                scene.add(rock);
                segmentData.meshes.push(rock);
            }
        }

        // å†…å­˜æ¸…ç†ï¼šä¿ç•™æœ€è¿‘80æ®µï¼Œåˆ é™¤è¿‡åçš„è·¯æ®µ
        roadSegments.push(segmentData);
        if (roadSegments.length > 80) {
            const oldSeg = roadSegments.shift();
            oldSeg.bodies.forEach(b => world.removeBody(b));
            oldSeg.meshes.forEach(m => {
                scene.remove(m);
                if(m.geometry) m.geometry.dispose();
                if(m.material) m.material.dispose();
            });
        }

        // æ›´æ–°ä¸Šä¸€æ®µçš„åæ ‡
        prevX = x; prevY = y; prevZ = z;
        segmentCounter++;
    }
    function createSimpleTree() {
        const g = new THREE.Group();
        const t = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 2), new THREE.MeshLambertMaterial({color:0x553311}));
        t.position.y=1;
        const l = new THREE.Mesh(new THREE.ConeGeometry(2, 5, 8), new THREE.MeshLambertMaterial({color:0x225511}));
        l.position.y=4.5;
        g.add(t); g.add(l);
        return g;
    }

    function handler(e) {
        const up = (e.type == 'keydown');
        const maxForce = 2500;
        const maxSteer = 0.45;


        // é¦–æ¬¡äº¤äº’å¯åŠ¨éŸ³ä¹
        if (up && !bgMusic) {
            initMusic();
            isMusicPlaying = !isMusicPlaying;
            bgMusic.play().catch(err => console.log("ç­‰å¾…äº¤äº’ä»¥æ’­æ”¾éŸ³é¢‘"));

            if (!audioCtx) {
                initWind();
                if (audioCtx.state === 'suspended') audioCtx.resume();
            }
        }

        switch(e.key.toLowerCase()) {
            case 'm': // M é”®åˆ‡æ¢é™éŸ³
                if (up && bgMusic) {
                    if (isMusicPlaying) {
                        bgMusic.pause();
                    } else {
                        bgMusic.play().catch(err => console.log("ç­‰å¾…äº¤äº’ä»¥æ’­æ”¾éŸ³é¢‘"));
                    }
                    isMusicPlaying = !isMusicPlaying;
                }
                break;
            case 'w':
                const f = up ? maxForce : 0;
                vehicle.applyEngineForce(0, 0); vehicle.applyEngineForce(0, 1);
                vehicle.applyEngineForce(f, 2); vehicle.applyEngineForce(f, 3);
                break;
            case 's':
                const b = up ? -maxForce : 0;
                vehicle.applyEngineForce(0, 0); vehicle.applyEngineForce(0, 1);
                vehicle.applyEngineForce(b, 2); vehicle.applyEngineForce(b, 3);
                break;
            case 'a':
                vehicle.setSteeringValue(up ? maxSteer : 0, 0);
                vehicle.setSteeringValue(up ? maxSteer : 0, 1);
                break;
            case 'd':
                vehicle.setSteeringValue(up ? -maxSteer : 0, 0);
                vehicle.setSteeringValue(up ? -maxSteer : 0, 1);
                break;
            case ' ':
                const br = up ? 100 : 0;
                vehicle.setBrake(br, 2); vehicle.setBrake(br, 3);
                break;
            case 'r':
                if(up) resetCar();
                break;
            case 'v':
                if (up) { // åªåœ¨é”®ä½å¼¹èµ·æ—¶è§¦å‘ä¸€æ¬¡
                    isFirstPerson = !isFirstPerson;
                    // åˆ‡æ¢å†…é¥°å›¾ç‰‡æ˜¾ç¤º
                    document.getElementById('cockpit-overlay').style.display = isFirstPerson ? 'block' : 'none';
                }
                break;
            case 'c':
                if (up) {
                    isCollectingMode = !isCollectingMode;
                    if (targetMarker) {
                        targetMarker.visible = isCollectingMode;
                    }
                    console.log(`%c ${isCollectingMode ? 'ğŸŸ¢ é‡‡é›†æ¨¡å¼å¼€å¯' : 'âšª é‡‡é›†æ¨¡å¼å…³é—­'}`,
                        `color: ${isCollectingMode ? '#0f0' : '#888'};`);
                }
                break;
            case 'l':
                if (up) {
                    window.learnFromHuman();
                }
                break;
            case 't':
                if (up) {
                    if (isTuningMode) {
                        window.stopTraining();  // è®­ç»ƒä¸­æŒ‰Tåœæ­¢
                    } else {
                        window.startTraining(); // éè®­ç»ƒæŒ‰Tå¼€å§‹
                    }
                }
                break;
        }
    }

    function resetCar() {
        chassisBody.position.copy(lastSafePosition);
        chassisBody.position.x += 2;
        chassisBody.position.y += 2;
        chassisBody.quaternion.copy(lastSafeQuaternion);
        chassisBody.velocity.set(0,0,0);
        chassisBody.angularVelocity.set(0,0,0);
    }

    function resetTuningScene() {
        if (traffic && traffic.vehicles) {
            traffic.vehicles.forEach(v => v.destroy());
            traffic.vehicles = [];
        }

        // åŸºäºç©å®¶ä½ç½®è®¡ç®—èµ·å§‹ç‚¹ï¼ˆå¾€å‰ä¸€ç‚¹ï¼Œä¸è¦å¤ªè¿œï¼‰
        const playerZ = chassisBody.position.z;
        const baseZ = playerZ + 10; // åœ¨ç©å®¶å‰æ–¹30ç±³å¼€å§‹ç”Ÿæˆ

        // 1. æ¸…ç†è°ƒä¼˜ç§ç¾¤ä¸­çš„æ—§è½¦
        tuner.population.forEach((ind, index) => {
            if (ind.car) {
                ind.car.destroy();
                ind.car = null;
            }

            // 2. åˆå§‹åŒ–æœ¬è½®æ•°æ®
            ind.isAlive = true;
            ind.distTraveled = 0;
            ind.totalCTE = 0;
            ind.totalSpeed = 0;
            ind.tickCount = 0;
            ind.lane = Math.random() > 0.5 ? 3.5 : -3.5;
            ind.startZ = baseZ - (index * 15); // æ‹‰å¼€15ç±³é—´è·ï¼Œé¿å…æŒ¤åœ¨ä¸€èµ·
            ind.lastDistCheck = 0;
            ind.uid = globalCarId++;
            ind.totalLifeTicks = 0;
            ind.stuckTicks = 0;

            // 3. ç”Ÿæˆæ–°è½¦
            ind.car = new NPCVehicle(ind.startZ, ind.lane, world, scene, ind.dna);
        });

        // æ›´æ–°è·¯ç‚¹
        traffic.generateWaypoints(baseZ);

        // é‡ç½®ä¸»å‚è€ƒä½“åˆ°å½“å‰è·¯é¢ä½ç½®
        const roadPoint = calculateRoadPoint(baseZ);
        chassisBody.velocity.set(0, 0, 0);
        chassisBody.position.set(roadPoint.x, roadPoint.y + 2, baseZ);

        // æ›´æ–°ç›¸æœºä½ç½®åˆ°è½¦è¾†é™„è¿‘
        if (orbitControls) {
            camera.position.set(roadPoint.x, roadPoint.y + 50, baseZ + 80);
            orbitControls.target.set(roadPoint.x, roadPoint.y, baseZ - 50);
            orbitControls.update();
        }

        console.log(`ğŸš— è®­ç»ƒåœºæ™¯é‡ç½®: baseZ=${baseZ.toFixed(0)}, è·¯é¢Y=${roadPoint.y.toFixed(1)}`);
    }

    // åœ¨ä¸» animate å¾ªç¯ä¸­
    function autoTuningLoop() {
        if (!tuner) {
            tuner = new AutoTuner(6);  // å‡å°‘åˆ°6è¾†è½¦
            resetTuningScene(); // ä»…åœ¨ç¬¬ä¸€æ¬¡æˆ–è¿›åŒ–æ—¶é‡ç½®
        }

        // è·å–å½“å‰å­˜æ´»çš„ NPC åˆ—è¡¨ç”¨äºé¿è®©è®¡ç®—
        const aliveNPCs = tuner.population
            .filter(ind => ind.isAlive && ind.car)
            .map(ind => ind.car);

        // åŠ é€Ÿä»¿çœŸï¼šæ¯å¸§è¿è¡Œ 4 æ¬¡ç‰©ç†
        for (let i = 0; i < 4; i++) {
            world.step(1 / 60);
            
            tuner.population.forEach(ind => {
                if (ind.isAlive && ind.car) {
                    // ä¿®æ­£ï¼šä¼ å…¥è·¯ç‚¹ã€å‚è€ƒä½“ã€ä»¥åŠæ‰€æœ‰NPCåˆ—è¡¨
                    ind.car.drive(traffic.waypoints, chassisBody, aliveNPCs);

                    const pos = ind.car.chassisBody.position;
                    ind.distTraveled = Math.abs(pos.z - ind.startZ); 

                    
                    const road = calculateRoadPoint(pos.z);
                    if (road) {
                        const currentCTE = Math.abs(pos.x - (road.x + ind.lane));
                        const currentSpeed = ind.car.chassisBody.velocity.length();
                        ind.totalCTE += currentCTE;
                        ind.totalSpeed += currentSpeed;
                        ind.tickCount++;
                        ind.totalLifeTicks++;

                        // å¯åŠ¨ä¿æŠ¤æœŸï¼ˆç¨³å®šæœŸ240 + ç¼“å†²60 = 300 ticksåå†æ£€æµ‹ï¼‰
                        const isWarmedUp = ind.tickCount > 300;

                        // å¡ä½æ£€æµ‹ï¼šåªåœ¨ä¿æŠ¤æœŸç»“æŸåæ‰å¼€å§‹æ£€æŸ¥
                        if (isWarmedUp && ind.tickCount % 60 === 0) {
                            const distDelta = ind.distTraveled - ind.lastDistCheck;
                            if (distDelta < 2) {
                                // å‰è¿›ä¸è¶³2ç±³ï¼Œå¢åŠ å¡ä½è®¡æ•°
                                ind.stuckTicks++;
                            } else {
                                // æœ‰å‰è¿›ï¼Œé‡ç½®è®¡æ•°
                                ind.stuckTicks = 0;
                            }
                            ind.lastDistCheck = ind.distTraveled;
                        }

                        // ç¿»è½¦æ£€æµ‹ï¼šè½¦èº«å€¾æ–œè¶…è¿‡60åº¦ï¼ˆå¯åŠ¨åï¼‰
                        const q = ind.car.chassisBody.quaternion;
                        const upY = 1 - 2 * (q.x * q.x + q.z * q.z);
                        const isFlipped = isWarmedUp && upY < 0.5;

                        // æ­»äº¡åˆ¤å®šï¼ˆè¿ç»­5æ¬¡æ£€æµ‹éƒ½æ²¡å‰è¿›æ‰ç®—å¡ä½ï¼‰
                        const isStuck = isWarmedUp && ind.stuckTicks >= 5;
                        const speed = ind.car.chassisBody.velocity.length();

                        if (ind.totalLifeTicks > 600 && ind.totalLifeTicks % 60 === 0) {
                          console.log(`è½¦#${ind.uid}: CTE=${currentCTE.toFixed(1)}, speed=${speed.toFixed(1)}, upY=${upY.toFixed(2)}, 
                            stuckTicks=${ind.stuckTicks}, dist=${ind.distTraveled.toFixed(1)}, lastDist=${ind.lastDistCheck.toFixed(1)}`);
                        }
                        // æ›´æ–°è½¦é¡¶æ ‡ç­¾
                        if (ind.car.updateLabel) {
                            const info = `spd:${speed.toFixed(1)} stk:${ind.stuckTicks} CTE:${currentCTE.toFixed(1)}`;
                            ind.car.updateLabel(ind.uid, info);
                        }

                        if (currentCTE > 10 || pos.y < -10 || isFlipped || isStuck) {
                            ind.isAlive = false;
                            ind.car.destroy();
                            ind.car = null;
                        }
                    }
                }
            });
        }

        tuningTimer += 4;

        const allDead = tuner.population.every(ind => !ind.isAlive);
        if (tuningTimer >= TEST_DURATION || allDead) {
            tuner.evolve();    
            resetTuningScene(); 
            tuningTimer = 0;
        }

        // è‡ªç”±ç›¸æœºæ§åˆ¶
        if (orbitControls) {
            orbitControls.update();
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        if (isTuningMode) {
          autoTuningLoop();
        } else {
          world.step(1 / 60);

          // --- æ ¸å¿ƒä¿®æ”¹ï¼šæ— é™ç”Ÿæˆè§¦å‘å™¨ ---
          if (chassisBody.position.z < prevZ + (segLen * 15)) {
              generateNextSegment();
          }

          // --- è®°å½•äººç±»é©¾é©¶æ•°æ®ï¼ˆè¡Œä¸ºå…‹éš†ï¼‰---
          const pos = chassisBody.position;
          const speed = chassisBody.velocity.length();
          const road = calculateRoadPoint(pos.z);

          // åªåœ¨é‡‡é›†æ¨¡å¼ä¸‹æ˜¾ç¤ºç»¿çƒå’Œè®°å½•æ•°æ®
          if (isCollectingMode) {
              // è®¡ç®—å¹¶æ˜¾ç¤ºé‡‡æ ·ç›®æ ‡ç‚¹ï¼ˆè®©äººç±»çœ‹åˆ°AIçœ‹åˆ°çš„ç›®æ ‡ï¼‰
              const targetRoad = calculateRoadPoint(pos.z - SAMPLE_LOOK_AHEAD);
              if (targetRoad && targetMarker) {
                  targetMarker.position.set(targetRoad.x, targetRoad.y + 1.5, targetRoad.z);
                  // è„‰å†²åŠ¨ç”»æ•ˆæœ
                  const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                  targetMarker.scale.setScalar(pulse);
              }
          }

          if (isCollectingMode && road && speed > 1) { // åªåœ¨é‡‡é›†æ¨¡å¼+ç§»åŠ¨æ—¶è®°å½•
              // è®¡ç®—çŠ¶æ€
              const cte = pos.x - road.x; // å¸¦ç¬¦å·çš„æ¨ªå‘åå·®
              const steer = vehicle.wheelInfos[0].steering || 0;
              const targetRoad = calculateRoadPoint(pos.z - SAMPLE_LOOK_AHEAD);

              if (targetRoad) {
                  visualChassis.updateMatrixWorld();
                  const invMat = new THREE.Matrix4().copy(visualChassis.matrixWorld).invert();
                  const worldTarget = new THREE.Vector3(targetRoad.x, targetRoad.y, targetRoad.z);
                  const localTarget = worldTarget.clone().applyMatrix4(invMat);
                  const angleToTarget = Math.atan2(localTarget.x, -localTarget.z);

                  humanDrivingData.totalCTE += Math.abs(cte);
                  humanDrivingData.sampleCount++;

                  // è®¡ç®—è¡Œé©¶è·ç¦»
                  if (humanDrivingData.lastZ !== 0) {
                      humanDrivingData.totalDistance += Math.abs(pos.z - humanDrivingData.lastZ);
                  }
                  humanDrivingData.lastZ = pos.z;

                  // è®¡ç®—åŠ é€Ÿåº¦ (m/sÂ²)
                  const acceleration = (speed - humanDrivingData.lastSpeed) * 60; // ä¹˜60æ˜¯å› ä¸ºæ¯å¸§1/60ç§’
                  humanDrivingData.lastSpeed = speed;

                  // æ¯5å¸§è®°å½•ä¸€ä¸ªçŠ¶æ€-åŠ¨ä½œå¯¹
                  if (humanDrivingData.sampleCount % 5 === 0) {
                      humanDrivingData.samples.push({
                          // çŠ¶æ€
                          angleToTarget: angleToTarget,  // ç›®æ ‡ç‚¹è§’åº¦ï¼ˆäººç±»è¿½ç€ç»¿çƒå¼€ï¼‰
                          cte: cte,                      // æ¨ªå‘åå·®
                          speed: speed,                  // å½“å‰é€Ÿåº¦
                          // åŠ¨ä½œ
                          steer: steer,                  // äººç±»çš„è½¬å‘è§’
                          acceleration: acceleration    // äººç±»çš„åŠ é€Ÿåº¦
                      });
                  }

                  // å®æ—¶æ˜¾ç¤ºï¼ˆæ¯120å¸§ï¼‰
                  if (humanDrivingData.sampleCount % 120 === 0) {
                      const avgCTE = humanDrivingData.totalCTE / humanDrivingData.sampleCount;
                      console.log(`ğŸ“Š è®°å½•ä¸­: æ ·æœ¬=${humanDrivingData.samples.length}, è·ç¦»=${humanDrivingData.totalDistance.toFixed(0)}m, å¹³å‡CTE=${avgCTE.toFixed(2)}m`);
                  }
              }
          }

          visualChassis.position.copy(chassisBody.position);
          visualChassis.quaternion.copy(chassisBody.quaternion);
          
          for (let i = 0; i < vehicle.wheelInfos.length; i++) {
              vehicle.updateWheelTransform(i);
              const t = vehicle.wheelInfos[i].worldTransform;
              visualWheels[i].position.copy(t.position);
              visualWheels[i].quaternion.copy(t.quaternion);
          }


          // å®šä¹‰ä¸¤ç§è§†è§’çš„å‚æ•°
          const tpSeatOffset = new THREE.Vector3(0, 5, 10);      // ç¬¬ä¸‰äººç§°ï¼šé«˜å¤„å¾€å
          const fpSeatOffset = new THREE.Vector3(-0.4, 1.5, -1);  // ç¬¬ä¸€äººç§°ï¼šé©¾é©¶å‘˜å¤´éƒ¨ä½ç½®

          const tpLookOffset = new THREE.Vector3(0, 0, -5);      // ç¬¬ä¸‰äººç§°ï¼šçœ‹è½¦å¤´å‰æ–¹
          const fpLookOffset = new THREE.Vector3(-0.4, -1.5, -10); // ç¬¬ä¸€äººç§°ï¼šå¹³è§†è¿œæ–¹

          // æ ¹æ®å½“å‰è§†è§’é€‰æ‹©å‚æ•°
          const currentSeat = isFirstPerson ? fpSeatOffset : tpSeatOffset;
          const currentLook = isFirstPerson ? fpLookOffset : tpLookOffset;

          // è®¡ç®—ç›¸æœºåœ¨ä¸–ç•Œç©ºé—´çš„ä½ç½®
          // .clone() å¾ˆé‡è¦ï¼Œé˜²æ­¢ä¿®æ”¹åŸå§‹å‘é‡
          const camPos = currentSeat.clone().applyMatrix4(visualChassis.matrixWorld);

          // å¹³æ»‘è·Ÿéš
          // ç¬¬ä¸€äººç§°éœ€è¦ lerp æé«˜ï¼ˆ0.9ï¼‰ç”šè‡³ç›´æ¥ copyï¼Œå¦åˆ™ä¼šæœ‰å»¶è¿Ÿæ„Ÿå¯¼è‡´æ™•è½¦
          // ç¬¬ä¸‰äººç§°å¯ä»¥ lerp ä½ä¸€ç‚¹ï¼ˆ0.1ï¼‰å¢åŠ åŠ¨æ„Ÿ
          camera.position.lerp(camPos, isFirstPerson ? 0.95 : 0.1);

          // è®¡ç®—ç›¸æœºçœ‹å‘çš„ç›®æ ‡ç‚¹
          const lookTarget = currentLook.clone().applyMatrix4(visualChassis.matrixWorld);
          camera.lookAt(lookTarget);
          // const seatOffset = new THREE.Vector3(0.4, 4, 8); 
          // const camPos = seatOffset.applyMatrix4(visualChassis.matrixWorld);
          // camera.position.lerp(camPos, 0.3);

          // const lookOffset = new THREE.Vector3(0.35, -0.1, -1); 
          // const lookTarget = lookOffset.applyMatrix4(visualChassis.matrixWorld);
          // camera.lookAt(lookTarget);

          const mPos = new THREE.Vector3(-1.2, 0.5, 0.5).applyMatrix4(visualChassis.matrixWorld);
          mirrorCamera.position.copy(mPos);
          const mLook = new THREE.Vector3(-5, -0.5, 15).applyMatrix4(visualChassis.matrixWorld);
          mirrorCamera.lookAt(mLook);

          mirrorRenderer.render(scene, mirrorCamera);

          if (chassisBody.position.y < prevY - 30) {
              console.warn(`[Reset] è§¦å‘å¤ä½! è½¦Y=${chassisBody.position.y.toFixed(1)}, prevY=${prevY.toFixed(1)}, å·®å€¼=${(chassisBody.position.y - prevY).toFixed(1)}`);
              resetCar();
          }
          if (Date.now() % 60 === 0 && chassisBody.position.y > -1) {
              lastSafePosition.copy(chassisBody.position);
              lastSafeQuaternion.copy(chassisBody.quaternion);
          }

          if (masterGain && windFilter) {
              const speed = chassisBody.velocity.length(); 
              const now = audioCtx.currentTime;

              // ä¾ç„¶æ˜¯é€Ÿåº¦è¶…è¿‡ 15 (çº¦ 50km/h) å¯åŠ¨
              if (speed < 15) {
                  masterGain.gain.setTargetAtTime(0, now, 0.1);
              } else {
                  // 1. éŸ³é‡ï¼šéšé€Ÿåº¦å¿«é€Ÿå¢å¼º
                  const targetGain = Math.min(Math.pow((speed - 15) / 40, 1.5), 1.2); 
                  masterGain.gain.setTargetAtTime(targetGain, now, 0.3);

                  // 2. é¢‘ç‡ï¼šå…³é”®ï¼ä¿æŒåœ¨ä½é¢‘åŒºé—´ (80Hz - 400Hz)
                  // åªæœ‰åœ¨ä½é¢‘å¾˜å¾Šï¼Œæ‰ä¼šæœ‰â€œéš†éš†â€çš„é‡æ„Ÿ
                  const targetFreq = 80 + (speed * 4); 
                  windFilter.frequency.setTargetAtTime(Math.min(targetFreq, 450), now, 0.3);
                  
                  // 3. åŠ¨æ€Qå€¼ï¼šè¶Šå¿«ï¼Œéœ‡åŠ¨æ„Ÿè¶Šå¼º
                  windFilter.Q.setTargetAtTime(1.0 + (speed / 30), now, 0.3);
              }
          }

          if (traffic) {
              traffic.update();
              // æ¯3ç§’æ‰“å°ä¸€æ¬¡äº¤é€šçŠ¶æ€
              if (Date.now() % 3000 < 20) {
                  console.log(`[Traffic] è½¦è¾†æ•°:${traffic.vehicles.length}, é™åˆ¶:${traffic.limit}, spawnTimer:${traffic.spawnTimer}, playerZ:${chassisBody.position.z.toFixed(0)}`);
              }
          }
        }
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        const m = document.getElementById('mirror-left');
        mirrorRenderer.setSize(m.clientWidth, m.clientHeight);
        mirrorCamera.aspect = m.clientWidth / m.clientHeight;
        mirrorCamera.updateProjectionMatrix();
    });
</script>
</body>
</html>