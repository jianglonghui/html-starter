<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ç¡¬æ ¸å±±è·¯é©¾é©¶ - æ— é™ç”Ÿæˆç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #87CEEB;
        }

        #game-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100vw;
            height: 56.25vw;
            /* 16:9 ratio */
            max-height: 100vh;
            max-width: 177.78vh;
            /* 16:9 ratio */
            transform: translate(-50%, -50%);
            overflow: hidden;
            background: #000;
            z-index: 5;
        }

        #cockpit-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            background-image: url('image22.png');
            background-size: 100% 100%;
            background-position: center bottom;
            background-repeat: no-repeat;
            filter:
                brightness(0.7)
                /* å‹ä½äº®åº¦ï¼Œæ¨¡æ‹Ÿè½¦å†…æš—å…‰ç¯å¢ƒ */
                contrast(1.1)
                /* ç¨å¾®å¢å¼ºå¯¹æ¯”åº¦ */
                saturate(0.8)
                /* é™ä½é¥±å’Œåº¦ï¼Œå»æ‰é‚£ç§å»‰ä»·çš„å½©è‰²æ„Ÿ */
                drop-shadow(0px 0px 20px rgba(0, 0, 0, 0.5));
            /* å¢åŠ è¾¹ç¼˜æš—éƒ¨ */

            /* --- æ–°å¢ï¼šæš—è§’æ•ˆæœ (Vignette) --- */
            mask-image: radial-gradient(circle, white 60%, black 120%);
        }

        #portrait-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            color: white;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-family: sans-serif;
            padding: 20px;
        }

        #portrait-warning svg {
            width: 50px;
            height: 50px;
            margin-bottom: 20px;
            fill: white;
        }

        @media (orientation: portrait) {
            #portrait-warning {
                display: flex;
            }
        }

        #mirror-left {
            position: absolute;
            left: 2.8%;
            bottom: 41%;
            width: 13.5%;
            height: 11%;
            z-index: 5;
            border-radius: 50% 50% 40% 40%;
            border: 2px solid #222;
            background: #000;
            overflow: hidden;
            transform: rotate(1deg) scale(-1, 1);
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 4px;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
            max-width: 80vw;
        }

        /* ç§»åŠ¨ç«¯æ§åˆ¶æŒ‰é’®æ ·å¼ */
        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            z-index: 100;
            pointer-events: none;
            user-select: none;
        }

        .control-group {
            position: absolute;
            pointer-events: auto;
        }

        .control-group-left {
            left: 10px;
            bottom: 15%;
        }

        .control-group-right {
            right: 10px;
            bottom: 15%;
        }

        .control-group-top {
            right: 20px;
            top: -200px;
        }

        /* ç›¸å¯¹ä½ç½® */

        .btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            margin: 5px;
            backdrop-filter: blur(5px);
            -webkit-tap-highlight-color: transparent;
        }

        .btn:active {
            background: rgba(255, 255, 255, 0.4);
            transform: scale(0.95);
        }

        .btn-rect {
            width: 80px;
            height: 40px;
            border-radius: 8px;
            font-size: 14px;
        }

        @media (max-width: 1024px),
        (pointer: coarse) {
            .mobile-controls {
                display: block;
            }

            #info {
                font-size: 10px;
                top: 5px;
                left: 5px;
                padding: 4px;
            }
        }

        /* Google Places è‡ªåŠ¨è¡¥å…¨ä¸‹æ‹‰æ¡†æ ·å¼ */
        .pac-container {
            z-index: 10000 !important;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            border: none;
            margin-top: 4px;
        }

        .pac-item {
            padding: 8px 12px;
            cursor: pointer;
        }

        .pac-item:hover {
            background: #f0f0f0;
        }

        .pac-item-query {
            font-size: 14px;
        }

        /* Start Screen Styles */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-family: 'Inter', sans-serif;
            backdrop-filter: blur(10px);
        }

        .start-title {
            font-size: 3rem;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            letter-spacing: 4px;
        }

        .mode-buttons {
            display: flex;
            gap: 2rem;
        }

        .mode-btn {
            padding: 1.5rem 3rem;
            font-size: 1.5rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .mode-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: white;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .mode-btn span {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        /* Room Menu Styles */
        #room-menu {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            width: 100%;
            max-width: 500px;
        }

        .room-list {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .room-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem 1.2rem;
            background: rgba(255, 255, 255, 0.05);
            margin-bottom: 0.5rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .room-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .room-info {
            display: flex;
            flex-direction: column;
        }

        .room-name {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .room-players {
            font-size: 0.8rem;
            opacity: 0.6;
        }

        .join-btn {
            padding: 0.5rem 1rem;
            background: #4CAF50;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
        }

        .room-actions {
            display: flex;
            gap: 1rem;
            width: 100%;
        }

        .action-btn {
            flex: 1;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            font-size: 1rem;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .back-btn {
            margin-top: 1rem;
            opacity: 0.6;
            cursor: pointer;
            text-decoration: underline;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "playroomkit": "https://esm.sh/playroomkit"
            }
        }
    </script>
    <!-- Playroom SDK is now in importmap -->
</head>

<body>
    <!-- API é…ç½®æ–‡ä»¶ -->
    <script src="config.js"></script>

    <!-- Google Maps Places API -->
    <script>
        (g => { var h, a, k, p = "The Google Maps JavaScript API", c = "google", l = "importLibrary", q = "__ib__", m = document, b = window; b = b[c] || (b[c] = {}); var d = b.maps || (b.maps = {}), r = new Set, e = new URLSearchParams, u = () => h || (h = new Promise(async (f, n) => { await (a = m.createElement("script")); e.set("libraries", [...r]); for (k in g) e.set(k.replace(/[A-Z]/g, t => "_" + t[0].toLowerCase()), g[k]); e.set("callback", c + ".maps." + q); a.src = `https://maps.${c}apis.com/maps/api/js?` + e; d[q] = f; a.onerror = () => h = n(Error(p + " could not load.")); a.nonce = m.querySelector("script[nonce]")?.nonce || ""; m.head.append(a) })); d[l] ? console.warn(p + " only loads once. Ignoring:", g) : d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n)) })({
            key: window.CONFIG?.GOOGLE_API_KEY || '',
            v: "beta"
        });
    </script>



    <div id="start-screen">
        <h1 class="start-title">ç¡¬æ ¸å±±è·¯é©¾é©¶</h1>
        <div id="mode-selection" class="mode-buttons">
            <button id="btn-single" class="mode-btn">
                ğŸ•¹ï¸ å•æœºæ¨¡å¼
                <span>ç‹¬è‡ªç£¨ç»ƒè½¦æŠ€</span>
            </button>
            <button id="btn-multi" class="mode-btn">
                ğŸŒ è”æœºæ¨¡å¼
                <span>åˆ›å»ºæˆ–åŠ å…¥æˆ¿é—´</span>
            </button>
        </div>

        <div id="room-menu">
            <h2>æˆ¿é—´åˆ—è¡¨</h2>
            <div class="room-list" id="room-list-container">
                <!-- Mock Rooms -->
                <div class="room-item" onclick="joinRoom('AKINA-01')">
                    <div class="room-info">
                        <span class="room-name">ç§‹åå±±é£™è½¦ç¾¤</span>
                        <span class="room-players">3/5 æ­£åœ¨é©¾é©¶</span>
                    </div>
                    <button class="join-btn">åŠ å…¥</button>
                </div>
                <div class="room-item" onclick="joinRoom('DRIFT-KING')">
                    <div class="room-info">
                        <span class="room-name">æ¼‚ç§»ä¹‹ç‹æŒ‘æˆ˜èµ›</span>
                        <span class="room-players">1/5 ç­‰å¾…ä¸­</span>
                    </div>
                    <button class="join-btn">åŠ å…¥</button>
                </div>
            </div>
            <div class="room-actions">
                <button class="action-btn" onclick="createRoom()">â• åˆ›å»ºæ–°æˆ¿é—´</button>
                <button class="action-btn" onclick="joinByCode()">ğŸ”‘ è¾“å…¥ä»£ç åŠ å…¥</button>
            </div>
            <span class="back-btn" onclick="showModeSelection()">è¿”å›æ¨¡å¼é€‰æ‹©</span>
        </div>
    </div>

    <div id="info">
        â›°ï¸ ç§‹åå±±ç‰¹è®­ (æ— é™ç”Ÿæˆç‰ˆ)<br>
        W åŠ é€Ÿ | S åˆ¹è½¦ | A/D è½¬å‘ | Space æ‰‹åˆ¹ | F é©¾é©¶
    </div>

    <!-- åœ°å€æœç´¢æ¡†ï¼ˆä»…åœ¨ Google 3D åœºæ™¯æ˜¾ç¤ºï¼‰ -->
    <div id="location-search" style="display: none; position: absolute; top: 10px; right: 10px; z-index: 100;">
        <div
            style="background: rgba(255,255,255,0.95); border-radius: 8px; padding: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); width: 280px;">
            <input type="text" id="address-input" placeholder="è¾“å…¥åœ°å€æœç´¢..."
                style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px; box-sizing: border-box;" />
            <div id="search-status" style="font-size: 11px; color: #666; margin-top: 4px; padding: 0 4px;"></div>
        </div>
    </div>

    <div id="game-container">
        <div id="cockpit-overlay"></div>
        <div id="mirror-left"></div>
        <!-- Utility buttons moved inside game-container to sit on center console -->
        <!-- å°åœ°å›¾ï¼ˆä»…åœ¨ Google 3D åœºæ™¯æ˜¾ç¤ºï¼Œå·¦ä¸‹è§’å¯¹é½éŸ³ä¹æŒ‰é’®å·¦ä¸‹è§’ï¼‰ -->
        <div id="minimap-container"
            style="display: none; position: absolute; top: 82%; left: calc(59% - 70px); transform: translateY(-100%); z-index: 15; pointer-events: none;">
            <div id="minimap"
                style="width: 300px; height: 180px; border-radius: 8px; box-shadow: 0 2px 15px rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.6);">
            </div>
        </div>

        <div id="utility-controls"
            style="position: absolute; top: calc(82% + 35px); left: 59%; transform: translate(-50%, -50%); pointer-events: auto; display: flex; flex-wrap: wrap; justify-content: center; width: 140px; z-index: 20;">
            <div id="btn-music" class="btn btn-rect" style="width: 35px; height: 35px; margin: 2px;">ğŸµ</div>
            <div id="btn-scene" class="btn btn-rect" style="width: 35px; height: 35px; margin: 2px;">ğŸŒ„</div>
            <div id="btn-fullscreen" class="btn btn-rect" style="width: 35px; height: 35px; margin: 2px;">â›¶</div>
            <div id="btn-reset" class="btn btn-rect" style="width: 55px; height: 30px; margin: 2px; font-size: 12px;">é‡ç½®
            </div>
            <div id="btn-view" class="btn btn-rect" style="width: 55px; height: 30px; margin: 2px; font-size: 12px;">è§†è§’
            </div>
        </div>
    </div>

    <div id="portrait-warning">
        <svg viewBox="0 0 24 24">
            <path
                d="M16.48 2.52c3.27 1.55 5.61 4.72 5.97 8.48h2c-.44-4.81-3.44-8.84-7.97-10.48l1.5 1.5-1.5 1.5-3.5-3.5 3.5-3.5 1.5 1.5-1.5 1.5zM7.52 21.48c-3.27-1.55-5.61-4.72-5.97-8.48h-2c.44 4.81 3.44 8.84 7.97 10.48l-1.5-1.5 1.5-1.5 3.5 3.5-3.5 3.5-1.5-1.5 1.5-1.5zM10 5h4c1.1 0 2 .9 2 2v10c0 1.1-.9 2-2 2h-4c-1.1 0-2-.9-2-2v-10c0-1.1.9-2 2-2zm0 2v10h4v-10h-4z" />
        </svg>
        è¯·å°†æ‰‹æœºæ¨ªå±ä½¿ç”¨ï¼Œä»¥è·å¾—æœ€ä½³é©¾é©¶ä½“éªŒ
    </div>

    <div class="mobile-controls">
        <div class="control-group control-group-left">
            <div id="btn-left" class="btn">â†</div>
            <div id="btn-right" class="btn">â†’</div>
        </div>
        <div class="control-group control-group-right">
            <div id="btn-up" class="btn">â†‘</div>
            <div id="btn-down" class="btn">â†“</div>
            <div id="btn-space" class="btn btn-rect">æ‰‹åˆ¹</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        import { Sky } from 'https://unpkg.com/three@0.160.0/examples/jsm/objects/Sky.js';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
        import { TrafficManager, NPCVehicle } from './traffic.js';
        import { AutoTuner } from './AutoTuner.js';
        import { trainedData } from './trained_data.js';
        import { MountainRoad, SeaHighway, TempleIsland, SceneList } from './scenes/index.js';
        import { MultiplayerManager } from './multiplayer.js';

        // Multiplayer Manager
        const multiplayer = new MultiplayerManager();
        let isMultiplayer = false;

        // Google 3D Tiles API Key (ä» config.js è¯»å–)
        window.GOOGLE_TILES_API_KEY = window.CONFIG?.GOOGLE_API_KEY || '';

        let orbitControls;

        let world, scene, camera, renderer;
        let mirrorCamera, mirrorRenderer;
        let vehicle, chassisBody;
        let sun;
        let visualChassis, visualWheels = [];
        let isFirstPerson = true; // é»˜è®¤å¼€å¯ç¬¬ä¸€äººç§°
        let bgMusic;
        let isMusicPlaying = false;
        let traffic;
        let roadMat, wallMat;

        let audioCtx;
        let windNoise;
        let windGain;
        let windFilter;
        let masterGain; // æ–°å¢ä¸»å¼€å…³

        let currentDriverId = null;
        let players = {};
        let myPlayer = null;

        console.log("Playroom SDK check:", typeof Playroom !== 'undefined' ? "Loaded" : "Not Loaded");

        // åˆå§‹åŒ– Playroom é€»è¾‘å·²ç§»è‡³ multiplayer.js

        function updateDriverUI(name) {
            let driverEl = document.getElementById('driver-info');
            if (!driverEl) {
                driverEl = document.createElement('div');
                driverEl.id = 'driver-info';
                driverEl.style.position = 'absolute';
                driverEl.style.top = '50px';
                driverEl.style.left = '10px';
                driverEl.style.color = '#fff';
                driverEl.style.zIndex = '20';
                driverEl.style.background = 'rgba(0,0,0,0.5)';
                driverEl.style.padding = '5px';
                driverEl.style.borderRadius = '4px';
                driverEl.style.fontFamily = 'monospace';
                document.body.appendChild(driverEl);
            }
            driverEl.textContent = `å½“å‰é©¾é©¶å‘˜: ${name}`;
        }

        // Multiplayer Callbacks
        multiplayer.onDriverChange = (id, name) => {
            updateDriverUI(name);
        };

        multiplayer.onCarStateSync = (state) => {
            if (chassisBody) {
                chassisBody.position.set(state.pos.x, state.pos.y, state.pos.z);
                chassisBody.quaternion.set(state.quat.x, state.quat.y, state.quat.z, state.quat.w);
                chassisBody.velocity.set(state.vel.x, state.vel.y, state.vel.z);
                chassisBody.angularVelocity.set(state.angVel.x, state.angVel.y, state.angVel.z);
            }
        };

        // Start Game Logic
        async function startGame(multi) {
            isMultiplayer = multi;
            if (!isMultiplayer) {
                document.getElementById('start-screen').style.display = 'none';
                init();
                animate();
            } else {
                showRoomMenu();
            }
        }

        function showRoomMenu() {
            document.getElementById('mode-selection').style.display = 'none';
            document.getElementById('room-menu').style.display = 'flex';
        }

        function showModeSelection() {
            document.getElementById('mode-selection').style.display = 'flex';
            document.getElementById('room-menu').style.display = 'none';
        }

        window.joinRoom = async function (roomId) {
            console.log("Joining room:", roomId);
            document.getElementById('start-screen').style.display = 'none';
            const success = await multiplayer.init();
            if (success) {
                init();
                animate();
            } else {
                alert("åŠ å…¥å¤±è´¥");
                showRoomMenu();
            }
        };

        window.createRoom = async function () {
            console.log("Creating room...");
            document.getElementById('start-screen').style.display = 'none';
            const success = await multiplayer.init();
            if (success) {
                init();
                animate();
            } else {
                alert("åˆ›å»ºå¤±è´¥");
                showRoomMenu();
            }
        };

        window.joinByCode = function () {
            const code = prompt("è¯·è¾“å…¥æˆ¿é—´ä»£ç :");
            if (code) {
                joinRoom(code);
            }
        };

        window.showModeSelection = showModeSelection;

        document.getElementById('btn-single').onclick = () => startGame(false);
        document.getElementById('btn-multi').onclick = () => startGame(true);

        let currentTrackIndex = 0;
        const playlist = [
            'traffic-264578.mp3',
            'podcast.m4a',
            'desert.m4a'
        ];
        let lastSafePosition = new CANNON.Vec3(0, 2, 0);
        let lastSafeQuaternion = new CANNON.Quaternion();

        // --- åœºæ™¯ç®¡ç† ---
        let currentScene = null;
        let currentSceneIndex = Math.floor(Math.random() * SceneList.length);
        const segLen = 15;        // æ¯æ®µé•¿åº¦ï¼ˆä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨ï¼‰

        // å…¨å±€ calculateRoadPoint ä¾› traffic.js ä½¿ç”¨
        window.calculateRoadPoint = function (z) {
            if (currentScene) {
                return currentScene.calculateRoadPoint(z);
            }
            return new THREE.Vector3(0, 0, z);
        };

        // åˆå§‹åŒ–åœºæ™¯
        function initScene(index) {
            const SceneClass = SceneList[index % SceneList.length].class;
            currentScene = new SceneClass(world, scene, roadMat, wallMat);
            currentSceneIndex = index;

            // ç”Ÿæˆåˆå§‹è·¯æ®µ
            for (let i = 0; i < 30; i++) {
                currentScene.generateNextSegment();
            }

            console.log(`%c ğŸ—ºï¸ åœºæ™¯: ${currentScene.getName()}`, 'background: #333; color: #fff; font-size: 14px;');

            // æ˜¾ç¤º/éšè—åœ°å€æœç´¢æ¡†å’Œå°åœ°å›¾
            const searchBox = document.getElementById('location-search');
            const minimapContainer = document.getElementById('minimap-container');
            if (currentScene.constructor.name === 'Google3DTiles') {
                searchBox.style.display = 'block';
                minimapContainer.style.display = 'block';
                initPlacesAutocomplete();
                initMinimap();
            } else {
                searchBox.style.display = 'none';
                minimapContainer.style.display = 'none';
            }
        }

        // åˆå§‹åŒ– Google Places è‡ªåŠ¨è¡¥å…¨
        let placesInitialized = false;
        async function initPlacesAutocomplete() {
            if (placesInitialized) return;

            try {
                const { Autocomplete } = await google.maps.importLibrary("places");

                const input = document.getElementById('address-input');
                const statusEl = document.getElementById('search-status');

                const autocomplete = new Autocomplete(input, {
                    fields: ['geometry', 'formatted_address', 'name']
                });

                autocomplete.addListener('place_changed', () => {
                    const place = autocomplete.getPlace();
                    if (place.geometry?.location) {
                        const lat = place.geometry.location.lat();
                        const lng = place.geometry.location.lng();
                        const name = place.name || place.formatted_address;

                        statusEl.textContent = `æ­£åœ¨åŠ è½½: ${name}`;
                        statusEl.style.color = '#0066cc';

                        if (currentScene && currentScene.setLocation) {
                            currentScene.setLocation(lat, lng, name);
                            setTimeout(() => {
                                statusEl.textContent = `âœ“ ${name}`;
                                statusEl.style.color = '#00aa00';
                            }, 2000);
                        }
                    }
                });

                placesInitialized = true;
                console.log('ğŸ“ åœ°å€æœç´¢å·²å¯ç”¨');

            } catch (err) {
                console.error('Places API åŠ è½½å¤±è´¥:', err);
            }
        }

        // åˆå§‹åŒ–å°åœ°å›¾
        let minimapInstance = null;
        let minimapMarker = null;
        let minimapInitialized = false;
        let minimapCounter = 0;

        async function initMinimap() {
            if (minimapInitialized && minimapInstance) {
                // å·²åˆå§‹åŒ–ï¼Œåªéœ€æ›´æ–°ä¸­å¿ƒç‚¹
                updateMinimapCenter();
                return;
            }

            // ç¡®ä¿åœºæ™¯å·²åŠ è½½ä¸”æœ‰ getCenter æ–¹æ³•
            if (!currentScene || typeof currentScene.getCenter !== 'function') {
                console.log('ç­‰å¾…åœºæ™¯åŠ è½½...');
                setTimeout(initMinimap, 500);
                return;
            }

            try {
                const { Map } = await google.maps.importLibrary("maps");
                const center = currentScene.getCenter();
                const mapEl = document.getElementById('minimap');

                minimapInstance = new Map(mapEl, {
                    center: center,
                    zoom: 17,
                    disableDefaultUI: true,
                    gestureHandling: 'none',
                    mapTypeId: 'roadmap'
                });

                // ä½¿ç”¨ Symbol æ ‡è®°ï¼ˆç®­å¤´ï¼Œä¸éœ€è¦ Map IDï¼‰
                minimapMarker = new google.maps.Marker({
                    position: center,
                    map: minimapInstance,
                    icon: {
                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                        scale: 5,
                        fillColor: '#ff3300',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 2,
                        rotation: 0
                    }
                });

                // ç›‘å¬ä½ç½®å˜æ›´äº‹ä»¶
                window.addEventListener('locationChanged', (e) => {
                    const { lat, lng } = e.detail;
                    minimapInstance.setCenter({ lat, lng });
                    minimapMarker.setPosition({ lat, lng });
                });

                minimapInitialized = true;
                console.log('ğŸ—ºï¸ å°åœ°å›¾å·²å¯ç”¨');

            } catch (err) {
                console.error('å°åœ°å›¾åˆå§‹åŒ–å¤±è´¥:', err);
            }
        }

        function updateMinimapCenter() {
            if (!minimapInstance || !currentScene || !currentScene.getCenter) return;
            const center = currentScene.getCenter();
            minimapInstance.setCenter(center);
            if (minimapMarker) {
                minimapMarker.setPosition(center);
            }
        }

        function updateMinimap() {
            if (!minimapInstance || !minimapMarker || !currentScene || !currentScene.localToLatLng) return;

            const pos = chassisBody.position;
            const carLatLng = currentScene.localToLatLng(pos.x, pos.z);

            // æ›´æ–°æ ‡è®°ä½ç½®
            minimapMarker.setPosition(carLatLng);

            // è®©åœ°å›¾è·Ÿéšè½¦è¾†
            minimapInstance.panTo(carLatLng);

            // æ›´æ–°è½¦è¾†æœå‘ï¼ˆåŸºäºé€Ÿåº¦æ–¹å‘ï¼‰
            const vel = chassisBody.velocity;
            if (vel.length() > 1) {
                const heading = Math.atan2(vel.x, -vel.z) * (180 / Math.PI);
                // æ›´æ–°ç®­å¤´æ—‹è½¬
                const icon = minimapMarker.getIcon();
                if (icon) {
                    icon.rotation = heading;
                    minimapMarker.setIcon(icon);
                }
            }
        }

        // åˆ‡æ¢åœºæ™¯
        function switchScene() {
            // æ¸…ç†æ—§åœºæ™¯
            if (currentScene) {
                currentScene.roadSegments.forEach(seg => {
                    seg.bodies.forEach(b => world.removeBody(b));
                    seg.meshes.forEach(m => {
                        scene.remove(m);
                        if (m.geometry) m.geometry.dispose();
                        if (m.material) {
                            if (Array.isArray(m.material)) {
                                m.material.forEach(mat => mat.dispose());
                            } else {
                                m.material.dispose();
                            }
                        }
                    });
                });
                // æ¸…ç†æ°´é¢ç­‰é¢å¤–å…ƒç´ 
                if (currentScene.waterMeshes) {
                    currentScene.waterMeshes.forEach(w => {
                        scene.remove(w);
                        w.geometry.dispose();
                        w.material.dispose();
                    });
                }
                // æ¸…ç† 3D Tiles ç­‰èµ„æº
                if (currentScene.dispose) {
                    currentScene.dispose();
                }
            }

            // é‡ç½®è½¦è¾†ä½ç½®
            chassisBody.position.set(0, 2, -5);
            chassisBody.velocity.set(0, 0, 0);
            chassisBody.angularVelocity.set(0, 0, 0);
            chassisBody.quaternion.set(0, 0, 0, 1);

            // åˆ›å»ºæ–°åœºæ™¯
            currentSceneIndex = (currentSceneIndex + 1) % SceneList.length;
            initScene(currentSceneIndex);

            // é‡ç½®äº¤é€š
            if (traffic) {
                traffic.vehicles.forEach(v => v.destroy());
                traffic.vehicles = [];
                traffic.generateWaypoints(chassisBody.position.z);
            }
        }
        // -----------------------



        let isTuningMode = false; // è®¾ä¸º false å…ˆè®°å½•äººç±»é©¾é©¶æ•°æ®
        let tuner = null;
        let tuningTimer = 0;
        const TEST_DURATION = 60 * 20; // æ¯ä»£æµ‹è¯• 20 ç§’ (60å¸§/ç§’ * 20)
        let globalCarId = 0; // å…¨å±€å”¯ä¸€è½¦è¾†ID

        // äººç±»é©¾é©¶æ•°æ®è®°å½•ï¼ˆè¡Œä¸ºå…‹éš†ï¼‰
        let humanDrivingData = {
            samples: [],           // çŠ¶æ€-åŠ¨ä½œå¯¹
            totalCTE: 0,
            sampleCount: 0,
            totalDistance: 0,
            lastZ: 0,
            lastSpeed: 0           // ç”¨äºè®¡ç®—åŠ é€Ÿåº¦
        };

        // é‡‡æ ·ç›®æ ‡ç‚¹å¯è§†åŒ–ï¼ˆè®©äººç±»çœ‹åˆ°AIçœ‹åˆ°çš„ç›®æ ‡ï¼‰
        let targetMarker = null;
        const SAMPLE_LOOK_AHEAD = 18; // é‡‡æ ·ç”¨çš„é¢„ç„è·ç¦»ï¼Œå’ŒAIè®­ç»ƒæ—¶ä¸€è‡´
        let isCollectingMode = false; // é‡‡é›†æ¨¡å¼å¼€å…³

        // å­¦ä¹ åˆ°çš„æ§åˆ¶ç­–ç•¥
        let learnedPolicy = null;

        // ä»æ–‡ä»¶åŠ è½½é¢„è®­ç»ƒæ•°æ®
        if (trainedData.samples && trainedData.samples.length > 0) {
            humanDrivingData.samples = trainedData.samples;
            window.humanDrivingSamples = trainedData.samples;
            console.log(`%c ğŸ“‚ ä»æ–‡ä»¶åŠ è½½äº† ${trainedData.samples.length} ä¸ªæ ·æœ¬`, 'color: #0f0;');
        }
        if (trainedData.learnedPolicy) {
            learnedPolicy = trainedData.learnedPolicy;
            window.learnedPolicy = trainedData.learnedPolicy;
            console.log('%c ğŸ“‚ ä»æ–‡ä»¶åŠ è½½äº†å­¦ä¹ ç­–ç•¥', 'color: #0f0;');
        }
        if (trainedData.bestDNA) {
            window.bestTrainedDNA = trainedData.bestDNA;
            console.log('%c ğŸ“‚ ä»æ–‡ä»¶åŠ è½½äº†æœ€ä½³å‚æ•°', 'color: #0f0;', trainedData.bestDNA);
        }

        // å¯¼å‡ºå½“å‰æ•°æ®ï¼ˆå¤åˆ¶è¾“å‡ºåˆ° trained_data.jsï¼‰
        window.exportTrainingData = function () {
            const data = {
                samples: humanDrivingData.samples,
                learnedPolicy: learnedPolicy,
                bestDNA: window.bestTrainedDNA
            };
            const jsonStr = JSON.stringify(data, null, 2);
            console.log('%c ğŸ“‹ å¤åˆ¶ä»¥ä¸‹å†…å®¹åˆ° trained_data.js:', 'background: #f0a; color: #fff; font-size: 14px;');
            console.log(`export const trainedData = ${jsonStr};`);

            // ä¹Ÿæä¾›ä¸‹è½½
            const blob = new Blob([`export const trainedData = ${jsonStr};`], { type: 'text/javascript' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'trained_data.js';
            a.click();
            URL.revokeObjectURL(url);
            console.log('%c â¬‡ï¸ æ–‡ä»¶å·²ä¸‹è½½ï¼Œæ›¿æ¢é¡¹ç›®ä¸­çš„ trained_data.js å³å¯', 'color: #0ff;');
        };

        // æŸ¥çœ‹äººç±»é©¾é©¶æ•°æ®
        window.getHumanBaseline = function () {
            if (humanDrivingData.samples.length === 0) {
                console.warn('æ²¡æœ‰è®°å½•åˆ°æ•°æ®ï¼Œè¯·å…ˆé©¾é©¶ä¸€æ®µæ—¶é—´ï¼');
                return null;
            }
            const avgCTE = humanDrivingData.totalCTE / humanDrivingData.sampleCount;
            const avgSpeed = humanDrivingData.samples.reduce((a, b) => a + b.speed, 0) / humanDrivingData.samples.length;
            console.log('%c äººç±»é©¾é©¶æ•°æ® ', 'background: #0a0; color: #fff; font-size: 14px;');
            console.table({
                'æ ·æœ¬æ•°': humanDrivingData.samples.length,
                'å¹³å‡CTE': avgCTE.toFixed(3) + 'm',
                'å¹³å‡é€Ÿåº¦': avgSpeed.toFixed(1) + 'm/s',
                'æ€»è¡Œé©¶è·ç¦»': humanDrivingData.totalDistance.toFixed(1) + 'm'
            });
            return { avgCTE, avgSpeed, samples: humanDrivingData.samples };
        };

        // ä»äººç±»æ•°æ®å­¦ä¹ æ§åˆ¶ç­–ç•¥ï¼ˆçº¿æ€§å›å½’æ‹Ÿåˆï¼‰
        window.learnFromHuman = function () {
            const samples = humanDrivingData.samples;
            if (samples.length < 100) {
                console.warn('æ•°æ®å¤ªå°‘ï¼Œè¯·è‡³å°‘é©¾é©¶30ç§’ä»¥ä¸Šï¼å½“å‰æ ·æœ¬æ•°ï¼š' + samples.length);
                return;
            }

            const n = samples.length;

            // 1. è®¡ç®—è½¬å‘å¢ç›Šï¼šsteer = steerGain * angleToTarget
            // ä½¿ç”¨æœ€å°äºŒä¹˜æ³•ï¼šsteerGain = Î£(angle * steer) / Î£(angleÂ²)
            let sumAngle2 = 0, sumAngleSteer = 0;
            samples.forEach(s => {
                sumAngle2 += s.angleToTarget * s.angleToTarget;
                sumAngleSteer += s.angleToTarget * s.steer;
            });
            const steerGain = Math.abs(sumAngleSteer / (sumAngle2 + 0.001));

            // 2. è®¡ç®—å¹³å‡é€Ÿåº¦
            const avgSpeed = samples.reduce((a, b) => a + b.speed, 0) / n;

            // 3. ä¼°ç®—å¼•æ“åŠ›ï¼šåŸºäºå¹³å‡é€Ÿåº¦åæ¨
            // AIå…¬å¼: force = (targetSpeed - currentSpeed) * engineForce
            // å‡è®¾ç¨³æ€æ—¶ force â‰ˆ é˜»åŠ›ï¼Œé€Ÿåº¦ä¸engineForceæˆæ­£æ¯”
            // ç»éªŒå…¬å¼ï¼šavgSpeed â‰ˆ 15m/s å¯¹åº” engineForce â‰ˆ 3500
            const engineForce = (avgSpeed / 15) * 3500;

            // 4. å¹³å‡CTEä½œä¸ºåŸºå‡†
            const avgCTE = humanDrivingData.totalCTE / humanDrivingData.sampleCount;

            learnedPolicy = {
                steerGain: steerGain,
                engineForce: engineForce,
                avgSpeed: avgSpeed,
                avgCTE: avgCTE,
                sampleCount: n
            };

            // åŒæ­¥åˆ°å…¨å±€ï¼Œä¾›AutoTunerå’ŒAIä½¿ç”¨
            window.learnedPolicy = learnedPolicy;
            window.humanDrivingSamples = samples;  // è¡Œä¸ºå…‹éš†ç”¨

            console.log('%c ğŸ“ å­¦ä¹ å®Œæˆï¼', 'background: #f0a; color: #fff; font-size: 16px;');
            console.log('%c è®¡ç®—å‡ºçš„AIå‚æ•°ï¼š', 'color: #0ff; font-weight: bold;');
            console.table({
                'steerGain (è½¬å‘å¢ç›Š)': learnedPolicy.steerGain.toFixed(3),
                'engineForce (å¼•æ“åŠ›)': learnedPolicy.engineForce.toFixed(0),
                'äººç±»å¹³å‡é€Ÿåº¦': learnedPolicy.avgSpeed.toFixed(1) + ' m/s',
                'äººç±»å¹³å‡CTE': learnedPolicy.avgCTE.toFixed(3) + ' m',
                'æ ·æœ¬æ•°é‡': learnedPolicy.sampleCount
            });
            console.log('%c è¡Œä¸ºå…‹éš†å·²å¯ç”¨ï¼AIå°†ç›´æ¥æ¨¡ä»¿ä½ çš„é©¾é©¶é£æ ¼', 'color: #0f0;');

            window.humanBaseline = {
                avgCTE: avgCTE,
                avgSpeed: avgSpeed
            };

            return learnedPolicy;
        };

        // å¼€å§‹è®­ç»ƒæ¨¡å¼
        window.startTraining = function () {
            if (!learnedPolicy) {
                console.warn('è¯·å…ˆè°ƒç”¨ learnFromHuman() å­¦ä¹ äººç±»é©¾é©¶ç­–ç•¥ï¼');
                return;
            }
            isTuningMode = true;
            console.log('%c ğŸš— å¼€å§‹AIè®­ç»ƒï¼Œä½¿ç”¨å­¦ä¹ åˆ°çš„ç­–ç•¥ ', 'background: #00f; color: #fff;');
        };

        // åœæ­¢è®­ç»ƒï¼Œåº”ç”¨ç»“æœåˆ°æ™®é€šæ¨¡å¼
        window.stopTraining = function () {
            if (!isTuningMode) {
                console.warn('å½“å‰ä¸åœ¨è®­ç»ƒæ¨¡å¼');
                return;
            }

            // æ¸…ç†è®­ç»ƒè½¦è¾†
            if (tuner && tuner.population) {
                tuner.population.forEach(ind => {
                    if (ind.car) {
                        ind.car.destroy();
                        ind.car = null;
                    }
                });
            }

            isTuningMode = false;
            tuner = null;

            console.log('%c ğŸ è®­ç»ƒç»“æŸï¼', 'background: #0a0; color: #fff; font-size: 16px;');
            if (window.bestTrainedDNA) {
                console.log('%c æœ€ä½³å‚æ•°å·²åº”ç”¨åˆ°æ™®é€šæ¨¡å¼ï¼š', 'color: #0ff;');
                console.table(window.bestTrainedDNA);
            }
            if (window.humanDrivingSamples) {
                console.log(`è¡Œä¸ºå…‹éš†æ ·æœ¬ï¼š${window.humanDrivingSamples.length} ä¸ª`);
            }
        };

        // init() and animate() will be called from startGame()

        function initWind() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();

            const bufferSize = 4 * audioCtx.sampleRate;
            const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            let b0, b1, b2, b3, b4, b5, b6;
            b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179;
                b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520;
                b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980;
                output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                output[i] *= 0.11;
                b6 = white * 0.115926;
            }

            windNoise = audioCtx.createBufferSource();
            windNoise.buffer = noiseBuffer;
            windNoise.loop = true;

            // --- æ ¸å¿ƒï¼šä½é€šæ»¤æ³¢å™¨ (äº§ç”Ÿéš†éš†å£°) ---
            windFilter = audioCtx.createBiquadFilter();
            windFilter.type = 'lowpass'; // æ”¹ä¸ºä½é€šï¼Œæ»¤æ‰æ²™æ²™å£°
            windFilter.frequency.value = 100; // åªè¦æä½é¢‘
            windFilter.Q.value = 2.0; // å¢åŠ ä¸€ç‚¹å…±é¸£æ„Ÿ

            // è°ƒåˆ¶å±‚ï¼šè´Ÿè´£â€œéš†â€”â€”éš†â€”â€”â€çš„èŠ‚å¥æ„Ÿ
            windGain = audioCtx.createGain();
            windGain.gain.value = 0.5;

            // ä½¿ç”¨æ›´æ…¢ã€ä¸è§„åˆ™çš„æŒ¯è¡
            const lfo = audioCtx.createOscillator();
            lfo.type = 'triangle'; // ä¸‰è§’æ³¢æ¯”æ­£å¼¦æ³¢æ›´æœ‰æ’å‡»æ„Ÿ
            lfo.frequency.value = 1.5;
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 0.3; // æ³¢åŠ¨å¾ˆå¤§ï¼Œäº§ç”Ÿèµ·ä¼æ„Ÿ
            lfo.connect(lfoGain);
            lfoGain.connect(windGain.gain);
            lfo.start();

            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0;

            // è¿è·¯
            windNoise.connect(windFilter);
            windFilter.connect(windGain);
            windGain.connect(masterGain);
            masterGain.connect(audioCtx.destination);

            windNoise.start();
        }

        function initMusic() {
            playTrack(currentTrackIndex);
        }

        function playTrack(index) {
            if (index < 0) index = playlist.length - 1;
            if (index >= playlist.length) index = 0;
            currentTrackIndex = index;

            if (bgMusic) {
                bgMusic.pause();
            }
            bgMusic = new Audio(playlist[currentTrackIndex]);
            bgMusic.volume = 0.4;
            bgMusic.addEventListener('ended', () => nextTrack());
            if (isMusicPlaying) {
                bgMusic.play().catch(err => console.log("ç­‰å¾…äº¤äº’ä»¥æ’­æ”¾éŸ³é¢‘"));
            }
            console.log(`æ­£åœ¨æ’­æ”¾: ${playlist[currentTrackIndex]}`);
        }

        function nextTrack() {
            playTrack(currentTrackIndex + 1);
        }

        function prevTrack() {
            playTrack(currentTrackIndex - 1);
        }

        function init() {

            world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82, 0) });
            roadMat = new CANNON.Material();
            wallMat = new CANNON.Material();
            const wheelMat = new CANNON.Material();

            const roadContact = new CANNON.ContactMaterial(roadMat, wheelMat, { friction: 1.5, restitution: 0.0 });
            const wallContact = new CANNON.ContactMaterial(wallMat, wheelMat, { friction: 3, restitution: 0.0 });

            world.addContactMaterial(roadContact);
            world.addContactMaterial(wallContact);

            scene = new THREE.Scene();

            // --- 1. å…ˆåˆ›å»ºå¤ªé˜³ç¯å…‰ (DirectionalLight) ---
            sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.castShadow = true;
            // é…ç½®é˜´å½±èŒƒå›´
            sun.shadow.camera.left = -150; sun.shadow.camera.right = 150;
            sun.shadow.camera.top = 150; sun.shadow.camera.bottom = -150;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            // 1. åˆ›å»ºå¤©ç©ºå¯¹è±¡
            const sky = new Sky();
            sky.scale.setScalar(450000); // æå…¶å·¨å¤§çš„çƒä½“
            scene.add(sky);

            // 2. é…ç½®å¤§æ°”å‚æ•°
            const skyUniforms = sky.material.uniforms;
            skyUniforms['turbidity'].value = 0.5;      // æµ‘æµŠåº¦ (1-20): è¶Šé«˜è¶Šåƒå¤§é›¾å¤©æˆ–é»„æ˜
            skyUniforms['rayleigh'].value = 4;       // ç‘åˆ©æ•£å°„ (0-4): è¶Šé«˜å¤©ç©ºè¶Šè“
            skyUniforms['mieCoefficient'].value = 0.001; // æ•£å°„ç³»æ•°: æ¨¡æ‹Ÿç©ºæ°”ä¸­çš„é¢—ç²’
            skyUniforms['mieDirectionalG'].value = 0.95;  // å¤ªé˜³å…‰æ™•çš„æ‰©æ•£åº¦

            // 3. è®¾ç½®å¤ªé˜³ä½ç½®
            const sunPosition = new THREE.Vector3();
            const elevation = 2;   // å¤ªé˜³é«˜åº¦è§’ (0=åœ°å¹³çº¿, 90=å¤´é¡¶)
            const azimuth = 180;   // å¤ªé˜³æ–¹ä½è§’
            const phi = THREE.MathUtils.degToRad(90 - elevation);
            const theta = THREE.MathUtils.degToRad(azimuth);
            sunPosition.setFromSphericalCoords(1, phi, theta);

            // å°†ä½ç½®ä¼ é€’ç»™å¤©ç©ºç€è‰²å™¨
            skyUniforms['sunPosition'].value.copy(sunPosition);

            // 4. åŒæ­¥åœºæ™¯å…‰ç…§
            // æ‰¾åˆ°ä½ åŸæœ‰çš„ DirectionalLight (sun)ï¼Œè®©å®ƒçš„ä½ç½®ä¸å¤©ç©ºçš„å¤ªé˜³ä½ç½®å¯¹é½
            sun.position.copy(sunPosition.multiplyScalar(100));

            // 5. ä¼˜åŒ–é›¾æ°”é¢œè‰² (è®©è¿œå¤„çš„é›¾ä¸å¤©ç©ºåœ°å¹³çº¿é¢œè‰²èåˆ)
            // è¿™é‡Œå»ºè®®ç”¨ FogExp2ï¼Œé¢œè‰²è®¾ä¸ºç•¥å¾®å‘ç™½/æµ…è“
            scene.fog = new THREE.FogExp2(0xaaccff, 0.0008);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x443322, 1.5);
            scene.add(hemiLight);


            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (window.innerWidth <= 1024 && window.matchMedia('(pointer: coarse)').matches);
            const fov = isMobile ? 75 : 60;
            camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 0.1, 1000);
            mirrorCamera = new THREE.PerspectiveCamera(60, 1.8, 0.1, 500);

            const container = document.getElementById('game-container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;

            renderer.toneMapping = THREE.ACESFilmicToneMapping; // ç”µå½±çº§è‰²è°ƒæ˜ å°„
            renderer.toneMappingExposure = 1.0;                // æ›å…‰åº¦
            renderer.outputColorSpace = THREE.SRGBColorSpace;   // å¼€å¯ sRGB è‰²å½©ç©ºé—´
            container.appendChild(renderer.domElement);

            // è‡ªç”±ç›¸æœºæ§åˆ¶ (AutoTuneræ¨¡å¼)
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.target.set(0, 0, -100); // çœ‹å‘è·¯çš„æ–¹å‘
            camera.position.set(0, 50, 50);       // ä¿¯è§†åˆå§‹ä½ç½®
            orbitControls.update();

            const mDiv = document.getElementById('mirror-left');
            mirrorRenderer = new THREE.WebGLRenderer({ alpha: false });
            mirrorRenderer.setSize(mDiv.clientWidth, mDiv.clientHeight);
            mDiv.appendChild(mirrorRenderer.domElement);

            // åˆå§‹åŒ–åœºæ™¯ç³»ç»Ÿ
            initScene(currentSceneIndex);

            // è½¦è¾†é…ç½®
            const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.2, 2.2));
            chassisBody = new CANNON.Body({ mass: 1500 });
            chassisBody.addShape(chassisShape);
            chassisBody.position.set(0, 2, -5);
            chassisBody.angularDamping = 0.5;
            window.chassisBody = chassisBody; // æš´éœ²ç»™åœºæ™¯è°ƒç”¨

            // è§†è§‰è½¦èº«ç»„ - è·‘è½¦é€ å‹
            visualChassis = new THREE.Group();

            // è½¦èº«æè´¨ - é‡‘å±æ©™è‰²
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0xff6600,
                metalness: 0.9,
                roughness: 0.15
            });
            const blackMat = new THREE.MeshStandardMaterial({
                color: 0x111111,
                metalness: 0.8,
                roughness: 0.2
            });
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                metalness: 1,
                roughness: 0.05,
                transparent: true,
                opacity: 0.7
            });

            // 1. ä¸»è½¦èº«åº•éƒ¨ - æµçº¿å‹
            const bodyLower = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.35, 4.6),
                bodyMat
            );
            bodyLower.position.y = 0.18;
            bodyLower.castShadow = true;
            visualChassis.add(bodyLower);

            // 2. è½¦å¤´ - å€¾æ–œé€ å‹
            const hoodGeo = new THREE.BufferGeometry();
            const hoodVerts = new Float32Array([
                // å‰è„¸ï¼ˆä½ï¼‰
                -0.95, 0.25, -2.3, 0.95, 0.25, -2.3, 0, 0.35, -2.3,
                // å¼•æ“ç›–é¡¶ï¼ˆé«˜ï¼‰
                -0.95, 0.55, -0.8, 0.95, 0.55, -0.8,
                // å·¦ä¾§é¢
                -0.95, 0.25, -2.3, -0.95, 0.55, -0.8, -1, 0.35, -0.8, -1, 0.25, -2.3,
                // å³ä¾§é¢
                0.95, 0.25, -2.3, 0.95, 0.55, -0.8, 1, 0.35, -0.8, 1, 0.25, -2.3,
            ]);
            const hood = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.4, 1.6),
                bodyMat
            );
            hood.position.set(0, 0.5, -1.4);
            hood.rotation.x = -0.15;
            hood.castShadow = true;
            visualChassis.add(hood);

            // 3. é©¾é©¶èˆ± - æˆ˜æ–—æœºåº§èˆ±é£æ ¼
            const cabinBase = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.3, 2.2),
                bodyMat
            );
            cabinBase.position.set(0, 0.5, 0.5);
            visualChassis.add(cabinBase);

            // æŒ¡é£ç»ç’ƒ - å€¾æ–œ
            const windshield = new THREE.Mesh(
                new THREE.BoxGeometry(1.6, 0.5, 0.8),
                glassMat
            );
            windshield.position.set(0, 0.75, -0.3);
            windshield.rotation.x = -0.5;
            visualChassis.add(windshield);

            // è½¦é¡¶ç»ç’ƒ
            const roofGlass = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 0.1, 1.2),
                glassMat
            );
            roofGlass.position.set(0, 0.9, 0.6);
            visualChassis.add(roofGlass);

            // åçª—
            const rearWindow = new THREE.Mesh(
                new THREE.BoxGeometry(1.4, 0.4, 0.5),
                glassMat
            );
            rearWindow.position.set(0, 0.7, 1.4);
            rearWindow.rotation.x = 0.4;
            visualChassis.add(rearWindow);

            // 4. è½¦å°¾ - æ‰©æ•£å™¨é£æ ¼
            const rear = new THREE.Mesh(
                new THREE.BoxGeometry(2, 0.5, 0.8),
                bodyMat
            );
            rear.position.set(0, 0.4, 1.9);
            rear.castShadow = true;
            visualChassis.add(rear);

            // 5. å°¾ç¿¼
            const spoilerBase = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.4, 0.1),
                blackMat
            );
            spoilerBase.position.set(-0.7, 0.7, 2.1);
            visualChassis.add(spoilerBase);
            const spoilerBase2 = spoilerBase.clone();
            spoilerBase2.position.set(0.7, 0.7, 2.1);
            visualChassis.add(spoilerBase2);

            const spoilerWing = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.08, 0.35),
                blackMat
            );
            spoilerWing.position.set(0, 0.95, 2.15);
            spoilerWing.rotation.x = -0.1;
            visualChassis.add(spoilerWing);

            // 6. ä¾§è£™
            const sideskirtL = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.2, 3.5),
                blackMat
            );
            sideskirtL.position.set(-1.0, 0.1, 0);
            visualChassis.add(sideskirtL);
            const sideskirtR = sideskirtL.clone();
            sideskirtR.position.set(1.0, 0.1, 0);
            visualChassis.add(sideskirtR);

            // 7. è½¦å¤´å¤§ç¯ - LEDé£æ ¼
            const lightGeo = new THREE.BoxGeometry(0.5, 0.1, 0.15);
            const lightMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 1
            });
            const leftLight = new THREE.Mesh(lightGeo, lightMat);
            leftLight.position.set(-0.6, 0.35, -2.35);
            const rightLight = leftLight.clone();
            rightLight.position.set(0.6, 0.35, -2.35);
            visualChassis.add(leftLight, rightLight);

            // æ—¥è¡Œç¯æ¡
            const drlGeo = new THREE.BoxGeometry(0.35, 0.03, 0.1);
            const drlMat = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.8
            });
            const drlL = new THREE.Mesh(drlGeo, drlMat);
            drlL.position.set(-0.6, 0.28, -2.35);
            const drlR = drlL.clone();
            drlR.position.set(0.6, 0.28, -2.35);
            visualChassis.add(drlL, drlR);

            // 8. å°¾ç¯ - è´¯ç©¿å¼
            const tailLightMat = new THREE.MeshStandardMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.8
            });
            const tailLight = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.08, 0.1),
                tailLightMat
            );
            tailLight.position.set(0, 0.55, 2.35);
            visualChassis.add(tailLight);

            // 9. è¿›æ°”å£è£…é¥°
            const intakeGeo = new THREE.BoxGeometry(0.3, 0.15, 0.05);
            const intakeMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const intakeL = new THREE.Mesh(intakeGeo, intakeMat);
            intakeL.position.set(-0.5, 0.2, -2.32);
            const intakeR = intakeL.clone();
            intakeR.position.set(0.5, 0.2, -2.32);
            visualChassis.add(intakeL, intakeR);

            scene.add(visualChassis);

            vehicle = new CANNON.RaycastVehicle({
                chassisBody: chassisBody,
                indexRightAxis: 0, indexUpAxis: 1, indexForwardAxis: 2,
            });
            window.vehicle = vehicle; // æš´éœ²ç»™è°ƒè¯•

            const wheelOptions = {
                radius: 0.45,
                directionLocal: new CANNON.Vec3(0, -1, 0),
                suspensionStiffness: 40,
                suspensionRestLength: 0.4,
                frictionSlip: 2.5,
                dampingRelaxation: 2.3, dampingCompression: 4.4,
                maxSuspensionForce: 100000,
                rollInfluence: 0.1,
                axleLocal: new CANNON.Vec3(1, 0, 0),
                chassisConnectionPointLocal: new CANNON.Vec3(0, 0, 0),
                maxSuspensionTravel: 0.2,
                customSlidingRotationalSpeed: -30,
                useCustomSlidingRotationalSpeed: true,
            };

            wheelOptions.chassisConnectionPointLocal.set(-1.1, 0, -1.4); vehicle.addWheel(wheelOptions);
            wheelOptions.chassisConnectionPointLocal.set(1.1, 0, -1.4); vehicle.addWheel(wheelOptions);
            wheelOptions.chassisConnectionPointLocal.set(-1.1, 0, 1.4); vehicle.addWheel(wheelOptions);
            wheelOptions.chassisConnectionPointLocal.set(1.1, 0, 1.4); vehicle.addWheel(wheelOptions);

            vehicle.addToWorld(world);

            const wheelGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.4, 24);
            wheelGeo.rotateZ(Math.PI / 2);
            // è§†è§‰è½®å­é€ å‹ï¼šå¤–èƒ + è½®æ¯‚
            vehicle.wheelInfos.forEach(() => {
                const wheelGroup = new THREE.Group();

                // å¤–èƒ (é»‘è‰²åœ†æŸ±)
                const tire = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.45, 0.45, 0.4, 24),
                    new THREE.MeshStandardMaterial({ color: 0x222222 })
                );
                tire.rotateZ(Math.PI / 2);

                // è½®æ¯‚ (é“¶è‰²è–„ç‰‡)
                const rim = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2),
                    new THREE.MeshStandardMaterial({ color: 0xbbbbbb, metalness: 0.9 })
                );
                rim.rotateZ(Math.PI / 2);
                rim.position.x = 0.21; // è´´åœ¨è½®èƒå¤–ä¾§

                wheelGroup.add(tire, rim);
                scene.add(wheelGroup);
                visualWheels.push(wheelGroup);
            });

            // åœ¨ init å‡½æ•°æœ«å°¾
            traffic = new TrafficManager(world, scene, chassisBody);
            traffic.generateWaypoints(chassisBody.position.z);

            // åˆ›å»ºé‡‡æ ·ç›®æ ‡ç‚¹æ ‡è®°ï¼ˆé†’ç›®çš„ç»¿è‰²å…‰çƒï¼‰
            const markerGeo = new THREE.SphereGeometry(1.5, 16, 16);
            const markerMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.8
            });
            targetMarker = new THREE.Mesh(markerGeo, markerMat);
            // æ·»åŠ å‘å…‰æ•ˆæœ
            const glowGeo = new THREE.SphereGeometry(2.5, 16, 16);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            targetMarker.add(glow);
            targetMarker.visible = false; // é»˜è®¤éšè—ï¼ŒæŒ‰Cå¼€å¯
            scene.add(targetMarker);

            document.addEventListener('keydown', handler);
            document.addEventListener('keyup', handler);

            // ç§»åŠ¨ç«¯è§¦æ‘¸äº‹ä»¶
            const setupMobileBtn = (id, key) => {
                const btn = document.getElementById(id);
                if (!btn) return;

                const start = (e) => {
                    e.preventDefault();
                    handler({ type: 'keydown', key: key, preventDefault: () => { } });
                };
                const end = (e) => {
                    e.preventDefault();
                    handler({ type: 'keyup', key: key, preventDefault: () => { } });
                };

                btn.addEventListener('touchstart', start, { passive: false });
                btn.addEventListener('touchend', end, { passive: false });
                btn.addEventListener('mousedown', start);
                btn.addEventListener('mouseup', end);
                btn.addEventListener('mouseleave', end);
            };

            setupMobileBtn('btn-left', 'a');
            setupMobileBtn('btn-right', 'd');
            setupMobileBtn('btn-up', 'w');
            setupMobileBtn('btn-down', 's');
            setupMobileBtn('btn-space', ' ');

            document.getElementById('btn-reset').addEventListener('click', () => {
                handler({ type: 'keydown', key: 'r', preventDefault: () => { } });
            });
            document.getElementById('btn-view').addEventListener('click', () => {
                handler({ type: 'keydown', key: 'v', preventDefault: () => { } });
            });

            document.getElementById('btn-fullscreen').addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log(`Error attempting to enable full-screen mode: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            });

            document.getElementById('btn-music').addEventListener('click', () => {
                if (!bgMusic) {
                    initMusic();
                    isMusicPlaying = true;
                    bgMusic.play().catch(err => console.log("ç­‰å¾…äº¤äº’ä»¥æ’­æ”¾éŸ³é¢‘"));
                    if (!audioCtx) {
                        initWind();
                        if (audioCtx.state === 'suspended') audioCtx.resume();
                    }
                } else {
                    if (isMusicPlaying) {
                        bgMusic.pause();
                    } else {
                        bgMusic.play().catch(err => console.log("ç­‰å¾…äº¤äº’ä»¥æ’­æ”¾éŸ³é¢‘"));
                    }
                    isMusicPlaying = !isMusicPlaying;
                }
            });

            document.getElementById('btn-scene').addEventListener('click', () => {
                switchScene();
            });

            window.addEventListener('resize', () => {
                const container = document.getElementById('game-container');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);

                if (mirrorRenderer) {
                    const mDiv = document.getElementById('mirror-left');
                    mirrorRenderer.setSize(mDiv.clientWidth, mDiv.clientHeight);
                }
            });

            document.getElementById('cockpit-overlay').style.display = isFirstPerson ? 'block' : 'none';
        }

        function handler(e) {
            // å¦‚æœç„¦ç‚¹åœ¨è¾“å…¥æ¡†æˆ–è‡ªåŠ¨è¡¥å…¨ç»„ä»¶ï¼Œå¿½ç•¥æ¸¸æˆå¿«æ·é”®
            const activeEl = document.activeElement;
            if (activeEl && (
                activeEl.tagName === 'INPUT' ||
                activeEl.tagName === 'TEXTAREA' ||
                activeEl.tagName === 'GMP-PLACE-AUTOCOMPLETE' ||
                activeEl.closest('gmp-place-autocomplete')
            )) {
                return;
            }

            const up = (e.type == 'keydown');
            const maxForce = 2500;
            const maxSteer = 0.45;


            // é¦–æ¬¡äº¤äº’å¯åŠ¨éŸ³ä¹
            if (up && !bgMusic) {
                initMusic();
                isMusicPlaying = !isMusicPlaying;
                bgMusic.play().catch(err => console.log("ç­‰å¾…äº¤äº’ä»¥æ’­æ”¾éŸ³é¢‘"));

                if (!audioCtx) {
                    initWind();
                    if (audioCtx.state === 'suspended') audioCtx.resume();
                }
            }

            switch (e.key.toLowerCase()) {
                case 'm': // M é”®åˆ‡æ¢é™éŸ³
                    if (up && bgMusic) {
                        if (isMusicPlaying) {
                            bgMusic.pause();
                        } else {
                            bgMusic.play().catch(err => console.log("ç­‰å¾…äº¤äº’ä»¥æ’­æ”¾éŸ³é¢‘"));
                        }
                        isMusicPlaying = !isMusicPlaying;
                    }
                    break;
                case 'u': // U é”®ä¸‹ä¸€é¦–
                    if (up && bgMusic) {
                        nextTrack();
                    }
                    break;
                case 'p': // P é”®ä¸Šä¸€é¦–
                    if (up && bgMusic) {
                        prevTrack();
                    }
                    break;
                case 'w':
                    if (isMultiplayer && !multiplayer.isDriver()) break;
                    const f = up ? maxForce : 0;
                    vehicle.applyEngineForce(0, 0); vehicle.applyEngineForce(0, 1);
                    vehicle.applyEngineForce(f, 2); vehicle.applyEngineForce(f, 3);
                    break;
                case 's':
                    if (isMultiplayer && !multiplayer.isDriver()) break;
                    const b = up ? -maxForce : 0;
                    vehicle.applyEngineForce(0, 0); vehicle.applyEngineForce(0, 1);
                    vehicle.applyEngineForce(b, 2); vehicle.applyEngineForce(b, 3);
                    break;
                case 'a':
                    if (isMultiplayer && !multiplayer.isDriver()) break;
                    vehicle.setSteeringValue(up ? maxSteer : 0, 0);
                    vehicle.setSteeringValue(up ? maxSteer : 0, 1);
                    break;
                case 'd':
                    if (isMultiplayer && !multiplayer.isDriver()) break;
                    vehicle.setSteeringValue(up ? -maxSteer : 0, 0);
                    vehicle.setSteeringValue(up ? -maxSteer : 0, 1);
                    break;
                case ' ':
                    if (isMultiplayer && !multiplayer.isDriver()) break;
                    const br = up ? 100 : 0;
                    vehicle.setBrake(br, 2); vehicle.setBrake(br, 3);
                    break;
                case 'r':
                    if (up) resetCar();
                    break;
                case 'v':
                    if (up) { // åªåœ¨é”®ä½å¼¹èµ·æ—¶è§¦å‘ä¸€æ¬¡
                        isFirstPerson = !isFirstPerson;
                        // åˆ‡æ¢å†…é¥°å›¾ç‰‡æ˜¾ç¤º
                        document.getElementById('cockpit-overlay').style.display = isFirstPerson ? 'block' : 'none';
                    }
                    break;
                case 'c':
                    if (up) {
                        isCollectingMode = !isCollectingMode;
                        if (targetMarker) {
                            targetMarker.visible = isCollectingMode;
                        }
                        console.log(`%c ${isCollectingMode ? 'ğŸŸ¢ é‡‡é›†æ¨¡å¼å¼€å¯' : 'âšª é‡‡é›†æ¨¡å¼å…³é—­'}`,
                            `color: ${isCollectingMode ? '#0f0' : '#888'};`);
                    }
                    break;
                case 'l':
                    if (up) {
                        window.learnFromHuman();
                    }
                    break;
                case 't':
                    if (up) {
                        if (isTuningMode) {
                            window.stopTraining();  // è®­ç»ƒä¸­æŒ‰Tåœæ­¢
                        } else {
                            window.startTraining(); // éè®­ç»ƒæŒ‰Tå¼€å§‹
                        }
                    }
                    break;
                case 'n':
                    if (up) {
                        switchScene();
                    }
                    break;
                case 'f': // F é”®æŠ¢å¤ºé©¾é©¶æƒ
                    if (up && isMultiplayer) {
                        multiplayer.claimDriver();
                        console.log("You are now the driver!");
                    }
                    break;
            }
        }

        // isDriver é€»è¾‘å·²ç§»è‡³ multiplayer.js

        function resetCar() {
            // åŸºäºé“è·¯è®¡ç®—æ­£ç¡®çš„å¤ä½ä½ç½®
            const road = currentScene.calculateRoadPoint(lastSafePosition.z);
            chassisBody.position.set(road.x, road.y + 1, lastSafePosition.z);
            chassisBody.quaternion.set(0, 0, 0, 1); // é‡ç½®ä¸ºæ­£å‘
            chassisBody.velocity.set(0, 0, 0);
            chassisBody.angularVelocity.set(0, 0, 0);
        }

        function resetTuningScene() {
            if (traffic && traffic.vehicles) {
                traffic.vehicles.forEach(v => v.destroy());
                traffic.vehicles = [];
            }

            // åŸºäºç©å®¶ä½ç½®è®¡ç®—èµ·å§‹ç‚¹ï¼ˆå¾€å‰ä¸€ç‚¹ï¼Œä¸è¦å¤ªè¿œï¼‰
            const playerZ = chassisBody.position.z;
            const baseZ = playerZ + 10; // åœ¨ç©å®¶å‰æ–¹30ç±³å¼€å§‹ç”Ÿæˆ

            // 1. æ¸…ç†è°ƒä¼˜ç§ç¾¤ä¸­çš„æ—§è½¦
            tuner.population.forEach((ind, index) => {
                if (ind.car) {
                    ind.car.destroy();
                    ind.car = null;
                }

                // 2. åˆå§‹åŒ–æœ¬è½®æ•°æ®
                ind.isAlive = true;
                ind.distTraveled = 0;
                ind.totalCTE = 0;
                ind.totalSpeed = 0;
                ind.tickCount = 0;
                ind.lane = Math.random() > 0.5 ? 3.5 : -3.5;
                ind.startZ = baseZ - (index * 15); // æ‹‰å¼€15ç±³é—´è·ï¼Œé¿å…æŒ¤åœ¨ä¸€èµ·
                ind.lastDistCheck = 0;
                ind.uid = globalCarId++;
                ind.totalLifeTicks = 0;
                ind.stuckTicks = 0;

                // 3. ç”Ÿæˆæ–°è½¦
                ind.car = new NPCVehicle(ind.startZ, ind.lane, world, scene, ind.dna);
            });

            // æ›´æ–°è·¯ç‚¹
            traffic.generateWaypoints(baseZ);

            // é‡ç½®ä¸»å‚è€ƒä½“åˆ°å½“å‰è·¯é¢ä½ç½®
            const roadPoint = calculateRoadPoint(baseZ);
            chassisBody.velocity.set(0, 0, 0);
            chassisBody.position.set(roadPoint.x, roadPoint.y + 2, baseZ);

            // æ›´æ–°ç›¸æœºä½ç½®åˆ°è½¦è¾†é™„è¿‘
            if (orbitControls) {
                camera.position.set(roadPoint.x, roadPoint.y + 50, baseZ + 80);
                orbitControls.target.set(roadPoint.x, roadPoint.y, baseZ - 50);
                orbitControls.update();
            }

            console.log(`ğŸš— è®­ç»ƒåœºæ™¯é‡ç½®: baseZ=${baseZ.toFixed(0)}, è·¯é¢Y=${roadPoint.y.toFixed(1)}`);
        }

        // åœ¨ä¸» animate å¾ªç¯ä¸­
        function autoTuningLoop() {
            if (!tuner) {
                tuner = new AutoTuner(6);  // å‡å°‘åˆ°6è¾†è½¦
                resetTuningScene(); // ä»…åœ¨ç¬¬ä¸€æ¬¡æˆ–è¿›åŒ–æ—¶é‡ç½®
            }

            // è·å–å½“å‰å­˜æ´»çš„ NPC åˆ—è¡¨ç”¨äºé¿è®©è®¡ç®—
            const aliveNPCs = tuner.population
                .filter(ind => ind.isAlive && ind.car)
                .map(ind => ind.car);

            // åŠ é€Ÿä»¿çœŸï¼šæ¯å¸§è¿è¡Œ 4 æ¬¡ç‰©ç†
            for (let i = 0; i < 4; i++) {
                world.step(1 / 60);

                tuner.population.forEach(ind => {
                    if (ind.isAlive && ind.car) {
                        // ä¿®æ­£ï¼šä¼ å…¥è·¯ç‚¹ã€å‚è€ƒä½“ã€ä»¥åŠæ‰€æœ‰NPCåˆ—è¡¨
                        ind.car.drive(traffic.waypoints, chassisBody, aliveNPCs);

                        const pos = ind.car.chassisBody.position;
                        ind.distTraveled = Math.abs(pos.z - ind.startZ);


                        const road = calculateRoadPoint(pos.z);
                        if (road) {
                            const currentCTE = Math.abs(pos.x - (road.x + ind.lane));
                            const currentSpeed = ind.car.chassisBody.velocity.length();
                            ind.totalCTE += currentCTE;
                            ind.totalSpeed += currentSpeed;
                            ind.tickCount++;
                            ind.totalLifeTicks++;

                            // å¯åŠ¨ä¿æŠ¤æœŸï¼ˆç¨³å®šæœŸ240 + ç¼“å†²60 = 300 ticksåå†æ£€æµ‹ï¼‰
                            const isWarmedUp = ind.tickCount > 300;

                            // å¡ä½æ£€æµ‹ï¼šåªåœ¨ä¿æŠ¤æœŸç»“æŸåæ‰å¼€å§‹æ£€æŸ¥
                            if (isWarmedUp && ind.tickCount % 60 === 0) {
                                const distDelta = ind.distTraveled - ind.lastDistCheck;
                                if (distDelta < 2) {
                                    // å‰è¿›ä¸è¶³2ç±³ï¼Œå¢åŠ å¡ä½è®¡æ•°
                                    ind.stuckTicks++;
                                } else {
                                    // æœ‰å‰è¿›ï¼Œé‡ç½®è®¡æ•°
                                    ind.stuckTicks = 0;
                                }
                                ind.lastDistCheck = ind.distTraveled;
                            }

                            // ç¿»è½¦æ£€æµ‹ï¼šè½¦èº«å€¾æ–œè¶…è¿‡60åº¦ï¼ˆå¯åŠ¨åï¼‰
                            const q = ind.car.chassisBody.quaternion;
                            const upY = 1 - 2 * (q.x * q.x + q.z * q.z);
                            const isFlipped = isWarmedUp && upY < 0.5;

                            // æ­»äº¡åˆ¤å®šï¼ˆè¿ç»­5æ¬¡æ£€æµ‹éƒ½æ²¡å‰è¿›æ‰ç®—å¡ä½ï¼‰
                            const isStuck = isWarmedUp && ind.stuckTicks >= 5;
                            const speed = ind.car.chassisBody.velocity.length();

                            if (ind.totalLifeTicks > 600 && ind.totalLifeTicks % 60 === 0) {
                                console.log(`è½¦#${ind.uid}: CTE=${currentCTE.toFixed(1)}, speed=${speed.toFixed(1)}, upY=${upY.toFixed(2)}, 
                            stuckTicks=${ind.stuckTicks}, dist=${ind.distTraveled.toFixed(1)}, lastDist=${ind.lastDistCheck.toFixed(1)}`);
                            }
                            // æ›´æ–°è½¦é¡¶æ ‡ç­¾
                            if (ind.car.updateLabel) {
                                const info = `spd:${speed.toFixed(1)} stk:${ind.stuckTicks} CTE:${currentCTE.toFixed(1)}`;
                                ind.car.updateLabel(ind.uid, info);
                            }

                            // å æ¯æ£€æµ‹ï¼šåç¦»é“è·¯ä¸­å¿ƒä¸”é«˜åº¦å·®å¤§äº30ï¼Œæˆ–ç¿»è½¦ï¼Œæˆ–å¡ä½
                            const heightDiff = road.y - pos.y;
                            const offRoadThreshold = currentScene ? currentScene.roadWidth / 2 + 5 : 12;
                            const isFallenOff = currentCTE > offRoadThreshold && heightDiff > 30;

                            if (isFallenOff || isFlipped || isStuck) {
                                ind.isAlive = false;
                                ind.car.destroy();
                                ind.car = null;
                            }
                        }
                    }
                });
            }

            tuningTimer += 4;

            const allDead = tuner.population.every(ind => !ind.isAlive);
            if (tuningTimer >= TEST_DURATION || allDead) {
                tuner.evolve();
                resetTuningScene();
                tuningTimer = 0;
            }

            // è‡ªç”±ç›¸æœºæ§åˆ¶
            if (orbitControls) {
                orbitControls.update();
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isTuningMode) {
                autoTuningLoop();
            } else {
                // --- åŠ¨æ€åœ°é¢æ›´æ–°å¿…é¡»åœ¨ç‰©ç†æ­¥è¿›å‰ ---
                if (currentScene && currentScene.updateDynamicGround) {
                    currentScene.updateDynamicGround(chassisBody);
                }

                world.step(1 / 60);

                // --- æ ¸å¿ƒä¿®æ”¹ï¼šæ— é™ç”Ÿæˆè§¦å‘å™¨ ---
                if (currentScene && chassisBody.position.z < currentScene.prevZ + (segLen * 15)) {
                    currentScene.generateNextSegment();
                }

                // --- æ³¢æµªåŠ¨ç”»æ›´æ–° ---
                if (currentScene && currentScene.updateWaves) {
                    currentScene.updateWaves(1 / 60);
                }

                // --- 3D Tiles æ›´æ–° ---
                if (currentScene && currentScene.update) {
                    currentScene.update(camera, renderer, chassisBody);
                }

                // --- Multiplayer Sync ---
                if (isMultiplayer) {
                    multiplayer.syncCarState(chassisBody);
                }

                // --- å°åœ°å›¾æ›´æ–°ï¼ˆæ¯10å¸§æ›´æ–°ä¸€æ¬¡ï¼‰---
                if (currentScene && currentScene.constructor.name === 'Google3DTiles') {
                    minimapCounter = (minimapCounter + 1) % 10;
                    if (minimapCounter === 0) {
                        updateMinimap();
                    }
                }

                // --- è½®å­æ¥è§¦çŠ¶æ€è°ƒè¯•ï¼ˆä»…åœ¨ Google 3D åœºæ™¯ä¸­æ˜¾ç¤ºï¼‰---
                if (currentScene && currentScene.constructor.name === 'Google3DTiles') {
                    const wheelStatus = vehicle.wheelInfos.map((w, i) =>
                        w.raycastResult.body ? 'â—' : 'â—‹'
                    ).join(' ');
                    const contactCount = vehicle.wheelInfos.filter(w => w.raycastResult.body).length;
                    const infoEl = document.getElementById('info');
                    if (infoEl && Date.now() % 500 < 20) {
                        const pos = chassisBody.position;
                        infoEl.innerHTML = `ğŸ™ï¸ Google 3D åŸå¸‚æ¢ç´¢<br>
                            ä½ç½®: (${pos.x.toFixed(0)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(0)})<br>
                            è½®èƒ: ${wheelStatus} (${contactCount}/4æ¥åœ°)<br>
                            é€Ÿåº¦: ${(chassisBody.velocity.length() * 3.6).toFixed(0)} km/h`;
                    }
                }

                // --- è®°å½•äººç±»é©¾é©¶æ•°æ®ï¼ˆè¡Œä¸ºå…‹éš†ï¼‰---
                const pos = chassisBody.position;
                const speed = chassisBody.velocity.length();
                const road = calculateRoadPoint(pos.z);

                // åªåœ¨é‡‡é›†æ¨¡å¼ä¸‹æ˜¾ç¤ºç»¿çƒå’Œè®°å½•æ•°æ®
                if (isCollectingMode) {
                    // è®¡ç®—å¹¶æ˜¾ç¤ºé‡‡æ ·ç›®æ ‡ç‚¹ï¼ˆè®©äººç±»çœ‹åˆ°AIçœ‹åˆ°çš„ç›®æ ‡ï¼‰
                    const targetRoad = calculateRoadPoint(pos.z - SAMPLE_LOOK_AHEAD);
                    if (targetRoad && targetMarker) {
                        targetMarker.position.set(targetRoad.x, targetRoad.y + 1.5, targetRoad.z);
                        // è„‰å†²åŠ¨ç”»æ•ˆæœ
                        const pulse = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                        targetMarker.scale.setScalar(pulse);
                    }
                }

                if (isCollectingMode && road && speed > 1) { // åªåœ¨é‡‡é›†æ¨¡å¼+ç§»åŠ¨æ—¶è®°å½•
                    // è®¡ç®—çŠ¶æ€
                    const cte = pos.x - road.x; // å¸¦ç¬¦å·çš„æ¨ªå‘åå·®
                    const steer = vehicle.wheelInfos[0].steering || 0;
                    const targetRoad = calculateRoadPoint(pos.z - SAMPLE_LOOK_AHEAD);

                    // è®¡ç®—å¡åº¦ (æ­£=ä¸Šå¡, è´Ÿ=ä¸‹å¡)
                    const aheadRoad = calculateRoadPoint(pos.z - 5);
                    const pitch = aheadRoad ? Math.atan2(aheadRoad.y - road.y, 5) : 0;

                    if (targetRoad) {
                        visualChassis.updateMatrixWorld();
                        const invMat = new THREE.Matrix4().copy(visualChassis.matrixWorld).invert();
                        const worldTarget = new THREE.Vector3(targetRoad.x, targetRoad.y, targetRoad.z);
                        const localTarget = worldTarget.clone().applyMatrix4(invMat);
                        const angleToTarget = Math.atan2(localTarget.x, -localTarget.z);

                        humanDrivingData.totalCTE += Math.abs(cte);
                        humanDrivingData.sampleCount++;

                        // è®¡ç®—è¡Œé©¶è·ç¦»
                        if (humanDrivingData.lastZ !== 0) {
                            humanDrivingData.totalDistance += Math.abs(pos.z - humanDrivingData.lastZ);
                        }
                        humanDrivingData.lastZ = pos.z;

                        // è®¡ç®—åŠ é€Ÿåº¦ (m/sÂ²)
                        const acceleration = (speed - humanDrivingData.lastSpeed) * 60; // ä¹˜60æ˜¯å› ä¸ºæ¯å¸§1/60ç§’
                        humanDrivingData.lastSpeed = speed;

                        // æ¯5å¸§è®°å½•ä¸€ä¸ªçŠ¶æ€-åŠ¨ä½œå¯¹
                        if (humanDrivingData.sampleCount % 5 === 0) {
                            humanDrivingData.samples.push({
                                // çŠ¶æ€
                                angleToTarget: angleToTarget,  // ç›®æ ‡ç‚¹è§’åº¦
                                cte: cte,                      // æ¨ªå‘åå·®
                                speed: speed,                  // å½“å‰é€Ÿåº¦
                                pitch: pitch,                  // å¡åº¦ï¼ˆæ­£=ä¸Šå¡ï¼Œè´Ÿ=ä¸‹å¡ï¼‰
                                // åŠ¨ä½œ
                                steer: steer,                  // äººç±»çš„è½¬å‘è§’
                                acceleration: acceleration    // äººç±»çš„åŠ é€Ÿåº¦
                            });
                        }

                        // å®æ—¶æ˜¾ç¤ºï¼ˆæ¯120å¸§ï¼‰
                        if (humanDrivingData.sampleCount % 120 === 0) {
                            const avgCTE = humanDrivingData.totalCTE / humanDrivingData.sampleCount;
                            console.log(`ğŸ“Š è®°å½•ä¸­: æ ·æœ¬=${humanDrivingData.samples.length}, è·ç¦»=${humanDrivingData.totalDistance.toFixed(0)}m, å¹³å‡CTE=${avgCTE.toFixed(2)}m`);
                        }
                    }
                }

                visualChassis.position.copy(chassisBody.position);
                visualChassis.quaternion.copy(chassisBody.quaternion);

                for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                    vehicle.updateWheelTransform(i);
                    const t = vehicle.wheelInfos[i].worldTransform;
                    visualWheels[i].position.copy(t.position);
                    visualWheels[i].quaternion.copy(t.quaternion);
                }


                // å®šä¹‰ä¸¤ç§è§†è§’çš„å‚æ•°
                const tpSeatOffset = new THREE.Vector3(0, 5, 10);      // ç¬¬ä¸‰äººç§°ï¼šé«˜å¤„å¾€å
                const fpSeatOffset = new THREE.Vector3(-0.4, 1.5, -1);  // ç¬¬ä¸€äººç§°ï¼šé©¾é©¶å‘˜å¤´éƒ¨ä½ç½®

                const tpLookOffset = new THREE.Vector3(0, 0, -5);      // ç¬¬ä¸‰äººç§°ï¼šçœ‹è½¦å¤´å‰æ–¹
                const fpLookOffset = new THREE.Vector3(-0.4, -1.5, -10); // ç¬¬ä¸€äººç§°ï¼šå¹³è§†è¿œæ–¹

                // æ ¹æ®å½“å‰è§†è§’é€‰æ‹©å‚æ•°
                const currentSeat = isFirstPerson ? fpSeatOffset : tpSeatOffset;
                const currentLook = isFirstPerson ? fpLookOffset : tpLookOffset;

                // è®¡ç®—ç›¸æœºåœ¨ä¸–ç•Œç©ºé—´çš„ä½ç½®
                // .clone() å¾ˆé‡è¦ï¼Œé˜²æ­¢ä¿®æ”¹åŸå§‹å‘é‡
                const camPos = currentSeat.clone().applyMatrix4(visualChassis.matrixWorld);

                // å¹³æ»‘è·Ÿéš
                // ç¬¬ä¸€äººç§°éœ€è¦ lerp æé«˜ï¼ˆ0.9ï¼‰ç”šè‡³ç›´æ¥ copyï¼Œå¦åˆ™ä¼šæœ‰å»¶è¿Ÿæ„Ÿå¯¼è‡´æ™•è½¦
                // ç¬¬ä¸‰äººç§°å¯ä»¥ lerp ä½ä¸€ç‚¹ï¼ˆ0.1ï¼‰å¢åŠ åŠ¨æ„Ÿ
                camera.position.lerp(camPos, isFirstPerson ? 0.95 : 0.1);

                // è®¡ç®—ç›¸æœºçœ‹å‘çš„ç›®æ ‡ç‚¹
                const lookTarget = currentLook.clone().applyMatrix4(visualChassis.matrixWorld);
                camera.lookAt(lookTarget);
                // const seatOffset = new THREE.Vector3(0.4, 4, 8); 
                // const camPos = seatOffset.applyMatrix4(visualChassis.matrixWorld);
                // camera.position.lerp(camPos, 0.3);

                // const lookOffset = new THREE.Vector3(0.35, -0.1, -1); 
                // const lookTarget = lookOffset.applyMatrix4(visualChassis.matrixWorld);
                // camera.lookAt(lookTarget);

                const mPos = new THREE.Vector3(-1.2, 0.5, 0.5).applyMatrix4(visualChassis.matrixWorld);
                mirrorCamera.position.copy(mPos);
                const mLook = new THREE.Vector3(-5, -0.5, 15).applyMatrix4(visualChassis.matrixWorld);
                mirrorCamera.lookAt(mLook);

                mirrorRenderer.render(scene, mirrorCamera);

                // å æ¯æ£€æµ‹ï¼šåç¦»é“è·¯ä¸­å¿ƒ ä¸” é«˜åº¦å·®å¤§äº30
                if (currentScene) {
                    const pos = chassisBody.position;
                    const road = calculateRoadPoint(pos.z);
                    const cte = Math.abs(pos.x - road.x); // æ¨ªå‘åç¦»è·ç¦»
                    const heightDiff = road.y - pos.y;    // é«˜åº¦å·®ï¼ˆæ­£å€¼è¡¨ç¤ºè½¦æ¯”è·¯é¢ä½ï¼‰
                    const offRoadThreshold = currentScene.roadWidth / 2 + 5; // é“è·¯åŠå®½ + 5ç±³ä½™é‡

                    if (cte > offRoadThreshold && heightDiff > 30) {
                        console.warn(`[Reset] å æ¯å¤ä½! CTE=${cte.toFixed(1)}, é˜ˆå€¼=${offRoadThreshold}, é«˜åº¦å·®=${heightDiff.toFixed(1)}`);
                        resetCar();
                    }
                }
                if (Date.now() % 60 === 0 && chassisBody.position.y > -1) {
                    lastSafePosition.copy(chassisBody.position);
                    lastSafeQuaternion.copy(chassisBody.quaternion);
                }

                if (masterGain && windFilter) {
                    const speed = chassisBody.velocity.length();
                    const now = audioCtx.currentTime;

                    // ä¾ç„¶æ˜¯é€Ÿåº¦è¶…è¿‡ 15 (çº¦ 50km/h) å¯åŠ¨
                    if (speed < 15) {
                        masterGain.gain.setTargetAtTime(0, now, 0.1);
                    } else {
                        // 1. éŸ³é‡ï¼šéšé€Ÿåº¦å¿«é€Ÿå¢å¼º
                        const targetGain = Math.min(Math.pow((speed - 15) / 40, 1.5), 1.2);
                        masterGain.gain.setTargetAtTime(targetGain, now, 0.3);

                        // 2. é¢‘ç‡ï¼šå…³é”®ï¼ä¿æŒåœ¨ä½é¢‘åŒºé—´ (80Hz - 400Hz)
                        // åªæœ‰åœ¨ä½é¢‘å¾˜å¾Šï¼Œæ‰ä¼šæœ‰â€œéš†éš†â€çš„é‡æ„Ÿ
                        const targetFreq = 80 + (speed * 4);
                        windFilter.frequency.setTargetAtTime(Math.min(targetFreq, 450), now, 0.3);

                        // 3. åŠ¨æ€Qå€¼ï¼šè¶Šå¿«ï¼Œéœ‡åŠ¨æ„Ÿè¶Šå¼º
                        windFilter.Q.setTargetAtTime(1.0 + (speed / 30), now, 0.3);
                    }
                }

                if (traffic) {
                    traffic.update();
                    // æ¯3ç§’æ‰“å°ä¸€æ¬¡äº¤é€šçŠ¶æ€
                    if (Date.now() % 3000 < 20) {
                        // console.log(`[Traffic] è½¦è¾†æ•°:${traffic.vehicles.length}, é™åˆ¶:${traffic.limit}, spawnTimer:${traffic.spawnTimer}, playerZ:${chassisBody.position.z.toFixed(0)}`);
                    }
                }
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            const m = document.getElementById('mirror-left');
            mirrorRenderer.setSize(m.clientWidth, m.clientHeight);
            mirrorCamera.aspect = m.clientWidth / m.clientHeight;
            mirrorCamera.updateProjectionMatrix();
        });
    </script>
</body>

</html>